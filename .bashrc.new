Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.a7O6BNUfXR/Render
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
BASH_COMPLETION=/usr/local/etc/bash_completion
BASH_COMPLETION_COMPAT_DIR=/usr/local/etc/bash_completion.d
BASH_COMPLETION_DIR=/usr/local/etc/bash_completion.d
BASH_LINENO=()
BASH_REMATCH=([0]="a")
BASH_SOURCE=()
BASH_VERSINFO=([0]="3" [1]="2" [2]="57" [3]="1" [4]="release" [5]="x86_64-apple-darwin18")
BASH_VERSION='3.2.57(1)-release'
COLUMNS=80
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
CPPFLAGS=-I/usr/local/opt/openblas/include
DIRSTACK=()
EUID=502
GROUPS=()
HISTFILE=/Users/adityakaria/.bash_sessions/09FC04B0-F13E-4FC0-B863-6EF70E25C695.historynew
HISTFILESIZE=500
HISTSIZE=500
HOME=/Users/adityakaria
HOSTNAME=Optimus-prime.local
HOSTTYPE=x86_64
IFS=$' \t\n'
LC_CTYPE=UTF-8
LDFLAGS=-L/usr/local/opt/openblas/lib
LINES=24
LOGNAME=adityakaria
MACHTYPE=x86_64-apple-darwin18
MAILCHECK=60
OLDPWD=/etc
OPTERR=1
OPTIND=1
OSTYPE=darwin18
PATH='/Users/adityakaria/.rbenv/shims:/usr/local/bin:/Users/adityakaria/flutter/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/opt/X11/bin:~/.dotnet/tools:/Library/Frameworks/Mono.framework/Versions/Current/Commands'
PIPESTATUS=([0]="127")
PKG_CONFIG_PATH=/usr/local/opt/openblas/lib/pkgconfig
PPID=2216
PROMPT_COMMAND=update_terminal_cwd
PS1='\h:\W \u\$ '
PS2='> '
PS4='+ '
PWD=/Users/adityakaria
RBENV_SHELL=bash
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHELL_SESSION_DID_HISTORY_CHECK=1
SHELL_SESSION_DID_INIT=1
SHELL_SESSION_DIR=/Users/adityakaria/.bash_sessions
SHELL_SESSION_FILE=/Users/adityakaria/.bash_sessions/09FC04B0-F13E-4FC0-B863-6EF70E25C695.session
SHELL_SESSION_HISTFILE=/Users/adityakaria/.bash_sessions/09FC04B0-F13E-4FC0-B863-6EF70E25C695.history
SHELL_SESSION_HISTFILE_NEW=/Users/adityakaria/.bash_sessions/09FC04B0-F13E-4FC0-B863-6EF70E25C695.historynew
SHELL_SESSION_HISTFILE_SHARED=/Users/adityakaria/.bash_history
SHELL_SESSION_HISTORY=1
SHELL_SESSION_TIMESTAMP_FILE=/Users/adityakaria/.bash_sessions/_expiration_check_timestamp
SHLVL=1
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.WxyfkxQ2xg/Listeners
TERM=xterm-256color
TERM_PROGRAM=Apple_Terminal
TERM_PROGRAM_VERSION=421
TERM_SESSION_ID=09FC04B0-F13E-4FC0-B863-6EF70E25C695
TMPDIR=/var/folders/g_/_11shpnn07z7hxmckhb8j0wr0000gp/T/
UID=502
USER=adityakaria
VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3
WINE_MASM_DIR=/Users/adityakaria/wine-masm
WORKON_HOME=/Users/adityakaria/.virtualenvsexport
XPC_FLAGS=0x0
XPC_SERVICE_NAME=0
_='export PATH=/Users/adityakaria/.rbenv/shims:/usr/local/bin:/Users/adityakaria/flutter/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/opt/X11/bin:~/.dotnet/tools:/Library/Frameworks/Mono.framework/Versions/Current/Commands'
_scp_path_esc='[][(){}<>",:;^&!$=?`|\\'\''[:space:]]'
__brew_cask_complete_caskroom () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local caskroom_dir="$(brew --prefix)/Caskroom/";
    local files=$(\ls ${caskroom_dir} 2>/dev/null);
    COMPREPLY=($(compgen -W "$files" -- "$cur"))
}
__brew_cask_complete_formulae () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local lib=$(brew --repository)/Library;
    local taps=${lib}/Taps;
    local casks=${lib}/Taps/homebrew/homebrew-cask/Casks;
    local ff=$(\ls ${casks} 2>/dev/null | \sed 's/\.rb//g');
    COMPREPLY=($(compgen -W "$ff" -- "$cur"))
}
__brew_cask_complete_installed () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local inst=$(brew cask list -1);
    COMPREPLY=($(compgen -W "$inst" -- "$cur"))
}
__brew_cask_complete_outdated () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local outdated=$(brew cask outdated --quiet);
    COMPREPLY=($(compgen -W "$outdated" -- "$cur"))
}
__brew_caskcomp () 
{ 
    local list s sep='
' IFS=' ''	''
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    for s in $1;
    do
        __brew_caskcomp_words_include "$s" && continue;
        list="$list$s$sep";
    done;
    IFS=$sep;
    COMPREPLY=($(compgen -W "$list" -- "$cur"))
}
__brew_caskcomp_prev () 
{ 
    local idx=$((COMP_CWORD - 1));
    local prv="${COMP_WORDS[idx]}";
    while [[ $prv == -* ]]; do
        idx=$((--idx));
        prv="${COMP_WORDS[idx]}";
    done;
    echo "$prv"
}
__brew_caskcomp_words_include () 
{ 
    local i=1;
    while [[ $i -lt $COMP_CWORD ]]; do
        if [[ "${COMP_WORDS[i]}" = "$1" ]]; then
            return 0;
        fi;
        i=$((++i));
    done;
    return 1
}
__brew_complete_formulae () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local formulas="$(brew search)";
    local shortnames="$(echo "$formulas" | \grep / | \cut -d / -f 3)";
    COMPREPLY=($(compgen -W "$formulas $shortnames" -- "$cur"))
}
__brew_complete_installed () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local inst="$(command ls "$(brew --cellar)" 2>/dev/null)";
    COMPREPLY=($(compgen -W "$inst" -- "$cur"))
}
__brew_complete_logs () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local logs="$(command ls "${HOMEBREW_LOGS:-${HOME}/Library/Logs/Homebrew/}" 2>/dev/null)";
    COMPREPLY=($(compgen -W "$logs" -- "$cur"))
}
__brew_complete_outdated () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local od="$(brew outdated --quiet)";
    COMPREPLY=($(compgen -W "$od" -- "$cur"))
}
__brew_complete_tapped () 
{ 
    local taplib="$(brew --repository)/Library/Taps";
    local dir taps;
    for dir in "$taplib"/*/*;
    do
        [[ -d "$dir" ]] || continue;
        dir="${dir#${taplib}/}";
        dir="${dir/homebrew-/}";
        taps="$taps $dir";
    done;
    __brewcomp "$taps"
}
__brew_complete_versions () 
{ 
    local formula="$1";
    local versions="$(brew list --versions "$formula")";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W "$versions" -X "$formula" -- "$cur"))
}
__brewcomp () 
{ 
    local list s sep='
' IFS=' ''	''
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    for s in $1;
    do
        __brewcomp_words_include "$s" && continue;
        list="$list$s$sep";
    done;
    IFS="$sep";
    COMPREPLY=($(compgen -W "$list" -- "$cur"))
}
__brewcomp_null () 
{ 
    COMPREPLY=""
}
__brewcomp_prev () 
{ 
    local idx="$((COMP_CWORD - 1))";
    local prv="${COMP_WORDS[idx]}";
    while [[ "$prv" = -* ]]; do
        idx="$((--idx))";
        prv="${COMP_WORDS[idx]}";
    done;
    echo "$prv"
}
__brewcomp_words_include () 
{ 
    local i=1;
    while [[ "$i" -lt "$COMP_CWORD" ]]; do
        if [[ "${COMP_WORDS[i]}" = "$1" ]]; then
            return 0;
        fi;
        i="$((++i))";
    done;
    return 1
}
__docker_append_to_completions () 
{ 
    COMPREPLY=(${COMPREPLY[@]/%/"$1"})
}
__docker_complete_capabilities_addable () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_CONTROL
		BLOCK_SUSPEND
		DAC_READ_SEARCH
		IPC_LOCK
		IPC_OWNER
		LEASE
		LINUX_IMMUTABLE
		MAC_ADMIN
		MAC_OVERRIDE
		NET_ADMIN
		NET_BROADCAST
		SYS_ADMIN
		SYS_BOOT
		SYSLOG
		SYS_MODULE
		SYS_NICE
		SYS_PACCT
		SYS_PTRACE
		SYS_RAWIO
		SYS_RESOURCE
		SYS_TIME
		SYS_TTY_CONFIG
		WAKE_ALARM
	" -- "$cur" ))
}
__docker_complete_capabilities_droppable () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_WRITE
		CHOWN
		DAC_OVERRIDE
		FOWNER
		FSETID
		KILL
		MKNOD
		NET_BIND_SERVICE
		NET_RAW
		SETFCAP
		SETGID
		SETPCAP
		SETUID
		SYS_CHROOT
	" -- "$cur" ))
}
__docker_complete_configs () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_configs "$@")" -- "$current"))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_containers "$@")" -- "$current"))
}
__docker_complete_containers_all () 
{ 
    __docker_complete_containers "$@" --all
}
__docker_complete_containers_in_network () 
{ 
    local containers=($(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1"));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_containers_removable () 
{ 
    __docker_complete_containers "$@" --filter status=created --filter status=exited
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers "$@" --filter status=running
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers "$@" --filter status=exited
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers "$@" --filter status=paused
}
__docker_complete_detach_keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_images () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_images "$@")" -- "$current"));
    __ltrim_colon_completions "$current"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_local_interfaces () 
{ 
    local additional_interface;
    if [ "$1" = "--add" ]; then
        additional_interface="$2";
        shift 2;
    fi;
    COMPREPLY=($( compgen -W "$(__docker_local_interfaces "$@") $additional_interface" -- "$cur" ))
}
__docker_complete_local_ips () 
{ 
    __docker_complete_local_interfaces --ip-only
}
__docker_complete_log_driver_options () 
{ 
    local key=$(__docker_map_key_of_current_option '--log-opt');
    case "$key" in 
        awslogs-create-group)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        awslogs-credentials-endpoint)
            COMPREPLY=($( compgen -W "/" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        fluentd-async-connect)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        fluentd-sub-second-precision)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        gelf-address)
            COMPREPLY=($( compgen -W "tcp udp" -S "://" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        gelf-compression-level)
            COMPREPLY=($( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ));
            return
        ;;
        gelf-compression-type)
            COMPREPLY=($( compgen -W "gzip none zlib" -- "${cur##*=}" ));
            return
        ;;
        line-only)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "blocking non-blocking" -- "${cur##*=}" ));
            return
        ;;
        syslog-address)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        syslog-facility)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ));
            return
        ;;
        syslog-format)
            COMPREPLY=($( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ));
            return
        ;;
        syslog-tls-ca-cert | syslog-tls-cert | syslog-tls-key)
            _filedir;
            return
        ;;
        syslog-tls-skip-verify)
            COMPREPLY=($( compgen -W "true" -- "${cur##*=}" ));
            return
        ;;
        splunk-url)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        splunk-gzip | splunk-insecureskipverify | splunk-verify-connection)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        splunk-format)
            COMPREPLY=($( compgen -W "inline json raw" -- "${cur##*=}" ));
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		logentries
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local common_options1="max-buffer-size mode";
    local common_options2="env env-regex labels";
    local awslogs_options="$common_options1 awslogs-create-group awslogs-credentials-endpoint awslogs-datetime-format awslogs-group awslogs-multiline-pattern awslogs-region awslogs-stream tag";
    local fluentd_options="$common_options1 $common_options2 fluentd-address fluentd-async-connect fluentd-buffer-limit fluentd-retry-wait fluentd-max-retries fluentd-sub-second-precision tag";
    local gcplogs_options="$common_options1 $common_options2 gcp-log-cmd gcp-meta-id gcp-meta-name gcp-meta-zone gcp-project";
    local gelf_options="$common_options1 $common_options2 gelf-address gelf-compression-level gelf-compression-type gelf-tcp-max-reconnect gelf-tcp-reconnect-delay tag";
    local journald_options="$common_options1 $common_options2 tag";
    local json_file_options="$common_options1 $common_options2 max-file max-size";
    local logentries_options="$common_options1 $common_options2 line-only logentries-token tag";
    local splunk_options="$common_options1 $common_options2 splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag";
    local syslog_options="$common_options1 $common_options2 syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag";
    local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $logentries_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gcplogs)
            COMPREPLY=($( compgen -W "$gcplogs_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        logentries)
            COMPREPLY=($( compgen -W "$logentries_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_networks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_networks "$@")" -- "$current"))
}
__docker_complete_nodes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_nodes "$@")" -- "$current"))
}
__docker_complete_plugins_bundled () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current"))
}
__docker_complete_plugins_installed () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_installed "$@")" -- "$current"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_restart () 
{ 
    case "$prev" in 
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
    esac;
    return 1
}
__docker_complete_runtimes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_runtimes)" -- "$cur"))
}
__docker_complete_secrets () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_secrets "$@")" -- "$current"))
}
__docker_complete_services () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_services "$@")" -- "$current"))
}
__docker_complete_services_and_tasks () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_services "$@") $(__docker_tasks)" -- "$cur"))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo "$cur" | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_stack_orchestrator_options () 
{ 
    case "$prev" in 
        --kubeconfig)
            _filedir;
            return 0
        ;;
        --namespace)
            return 0
        ;;
        --orchestrator)
            COMPREPLY=($( compgen -W "all kubernetes swarm" -- "$cur"));
            return 0
        ;;
    esac;
    return 1
}
__docker_complete_stacks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_stacks "$@")" -- "$current"))
}
__docker_complete_user_group () 
{ 
    if [[ $cur == *:* ]]; then
        COMPREPLY=($(compgen -g -- "${cur#*:}"));
    else
        COMPREPLY=($(compgen -u -S : -- "$cur"));
        __docker_nospace;
    fi
}
__docker_complete_volumes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_volumes "$@")" -- "$current"))
}
__docker_configs () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_CONFIG_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q config ls --format "$format" "$@"
}
__docker_containers () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Names}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS}" = yes ]; then
                format='{{.ID}} {{.Names}}';
            else
                format='{{.Names}}';
            fi;
        fi;
    fi;
    __docker_q ps --format "$format" "$@"
}
__docker_daemon_is_experimental () 
{ 
    [ "$(__docker_q version -f '{{.Server.Experimental}}')" = "true" ]
}
__docker_daemon_os_is () 
{ 
    local expected_os="$1";
    local actual_os=${daemon_os=$(__docker_q version -f '{{.Server.Os}}')};
    [ "$actual_os" = "$expected_os" ]
}
__docker_images () 
{ 
    local repo_format='{{.Repository}}';
    local tag_format='{{.Repository}}:{{.Tag}}';
    local id_format='{{.ID}}';
    local all;
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" = "all" ]; then
        all='--all';
    fi;
    while true; do
        case "$1" in 
            --repo)
                format+="$repo_format\n";
                shift
            ;;
            --tag)
                if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
                    format+="$tag_format\n";
                fi;
                shift
            ;;
            --id)
                if [[ $DOCKER_COMPLETION_SHOW_IMAGE_IDS =~ ^(all|non-intermediate)$ ]]; then
                    format+="$id_format\n";
                fi;
                shift
            ;;
            --force-tag)
                format+="$tag_format\n";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q image ls --no-trunc --format "${format%\\n}" $all "$@" | grep -v '<none>$'
}
__docker_local_interfaces () 
{ 
    command -v ip > /dev/null 2>&1 || return;
    local format;
    if [ "$1" = "--ip-only" ]; then
        format='\1';
        shift;
    else
        format='\1 \2';
    fi;
    ip addr show scope global 2> /dev/null | sed -n "s| \+inet \([0-9.]\+\).* \([^ ]\+\)|$format|p"
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q network ls --format "$format" "$@"
}
__docker_nodes () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_NODE_IDS" = yes ]; then
        format='{{.ID}} {{.Hostname}}';
    else
        format='{{.Hostname}}';
    fi;
    local add=();
    while true; do
        case "$1" in 
            --id)
                format='{{.ID}}';
                shift
            ;;
            --name)
                format='{{.Hostname}}';
                shift
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "$(__docker_q node ls --format "$format" "$@")" "${add[@]}"
}
__docker_nospace () 
{ 
    type compopt >&/dev/null && compopt -o nospace
}
__docker_plugins_bundled () 
{ 
    local type add=() remove=();
    while true; do
        case "$1" in 
            --type)
                type="$2";
                shift 2
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            --remove)
                remove+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugins=($(__docker_q info --format "{{range \$i, \$p := .Plugins.$type}}{{.}} {{end}}"));
    for del in "${remove[@]}";
    do
        plugins=(${plugins[@]/$del/});
    done;
    echo "${plugins[@]}" "${add[@]}"
}
__docker_plugins_installed () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_PLUGIN_IDS" = yes ]; then
        format='{{.ID}} {{.Name}}';
    else
        format='{{.Name}}';
    fi;
    __docker_q plugin ls --format "$format" "$@"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ "$counter" -le "$cword" ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo $counter
}
__docker_q () 
{ 
    docker ${host:+-H "$host"} ${config:+--config "$config"} "$@" 2> /dev/null
}
__docker_runtimes () 
{ 
    __docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}
__docker_secrets () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_SECRET_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q secret ls --format "$format" "$@"
}
__docker_services () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS}" = yes ] && fields='$1,$2';
    if [ "$1" = "--id" ]; then
        fields='$1';
        shift;
    else
        if [ "$1" = "--name" ]; then
            fields='$2';
            shift;
        fi;
    fi;
    __docker_q service ls "$@" | awk "NR>1 {print $fields}"
}
__docker_stack_orchestrator_is () 
{ 
    case "$1" in 
        kubernetes)
            if [ -z "$stack_orchestrator_is_kubernetes" ]; then
                __docker_q stack ls --help | grep -qe --namespace;
                stack_orchestrator_is_kubernetes=$?;
            fi;
            return $stack_orchestrator_is_kubernetes
        ;;
        swarm)
            if [ -z "$stack_orchestrator_is_swarm" ]; then
                __docker_q stack deploy --help | grep -qe "with-registry-auth";
                stack_orchestrator_is_swarm=$?;
            fi;
            return $stack_orchestrator_is_swarm
        ;;
        *)
            return 1
        ;;
    esac
}
__docker_stacks () 
{ 
    __docker_q stack ls | awk 'NR>1 {print $1}'
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand//-/_};
                declare -F "$completions_func" > /dev/null && "$completions_func";
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_tasks () 
{ 
    __docker_q service ps --format '{{.ID}}' ""
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo "${words[$counter + 1]}";
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__docker_volumes () 
{ 
    __docker_q volume ls -q "$@"
}
__expand_tilde_by_ref () 
{ 
    if [ "${!1:0:1}" = "~" ]; then
        if [ "${!1}" != "${!1//\/}" ]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur2;
    local cur="$COMP_LINE";
    local index="$COMP_POINT";
    for ((i = 0; i <= cword; ++i ))
    do
        while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
            cur="${cur:1}";
            ((index--));
        done;
        if [[ "$i" -lt "$cword" ]]; then
            local old_size="${#cur}";
            cur="${cur#${words[i]}}";
            local new_size="${#cur}";
            index=$(( index - old_size + new_size ));
        fi;
    done;
    if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
        cur2=${words[cword]};
    else
        cur2=${cur:0:$index};
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "$cur2"
}
__linux_fstab_unescape () 
{ 
    eval $1="'${!1//\'/\047}'";
    eval $1="'${!1/%\\/\\\\}'";
    eval "$1=$'${!1}'"
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && ( ${BASH_VERSINFO[0]} -lt 4 || ( ${BASH_VERSINFO[0]} -ge 4 && "$COMP_WORDBREAKS" == *:* ) ) ]]; then
        local colon_word=${1%${1##*:}};
        local i=${#COMPREPLY[*]};
        while [ $((--i)) -ge 0 ]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && -n ${COMP_WORDS[$i]} && ${COMP_WORDS[$i]//[^$exclude]} == ${COMP_WORDS[$i]} ]]; do
                [ $j -ge 2 ] && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [ $i = $COMP_CWORD ] && eval $3=$j;
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
_aclocal () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --print-ac-dir | --version)
            return 0
        ;;
        --acdir | -I)
            _filedir -d;
            return 0
        ;;
        --output)
            _filedir;
            return 0
        ;;
        --warnings | -W)
            local cats=(syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    _longopt $1
}
_alias () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in 
        *[^=])
            COMPREPLY=($( compgen -A alias -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( alias ${cur%=} 2>/dev/null | sed                 -e 's|^alias '"$cur"'\(.*\)$|\1|' )")
        ;;
    esac
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_autoconf () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V | --trace | -t)
            return 0
        ;;
        --output | -o)
            _filedir;
            return 0
        ;;
        --warnings | -W)
            local cats=(cross obsolete syntax);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return;
    fi;
    _filedir '@(ac|in)'
}
_automake () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --version)
            return 0
        ;;
        --warnings | -W)
            local cats=(gnu obsolete override portability syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --libdir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return;
    fi;
    _filedir
}
_autoreconf () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V)
            return 0
        ;;
        --warnings | -W)
            local cats=(cross gnu obsolete override portability syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return 0;
    fi;
    if [[ $1 == autoheader ]]; then
        _filedir '@(ac|in)';
    else
        _filedir -d;
    fi
}
_autoscan () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V)
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return 0;
    fi;
    if [[ $1 == autoupdate ]]; then
        _filedir '@(ac|in)';
    else
        _filedir -d;
    fi
}
_available_interfaces () 
{ 
    local cmd;
    if [ "${1:-}" = -w ]; then
        cmd="iwconfig";
    else
        if [ "${1:-}" = -a ]; then
            cmd="ifconfig";
        else
            cmd="ifconfig -a";
        fi;
    fi;
    COMPREPLY=($( eval PATH="$PATH:/sbin" $cmd 2>/dev/null |         awk '/^[^ \t]/ { print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_brctl () 
{ 
    local cur command;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    command=${COMP_WORDS[1]};
    case $COMP_CWORD in 
        1)
            COMPREPLY=($( compgen -W "addbr delbr addif delif                 setageing setbridgeprio setfd sethello                 setmaxage setpathcost setportprio show                 showmacs showstp stp" -- "$cur" ))
        ;;
        2)
            case $command in 
                show)

                ;;
                *)
                    COMPREPLY=($( compgen -W "$(brctl show |                         awk 'NR>1 {print $1}' )" -- "$cur" ))
                ;;
            esac
        ;;
        3)
            case $command in 
                addif | delif)
                    _configured_interfaces
                ;;
                stp)
                    COMPREPLY=($( compgen -W 'on off' -- "$cur" ))
                ;;
            esac
        ;;
    esac
}
_brew () 
{ 
    local i=1 cmd;
    while [[ "$i" -lt "$COMP_CWORD" ]]; do
        local s="${COMP_WORDS[i]}";
        case "$s" in 
            --*)
                cmd="$s";
                break
            ;;
            -*)

            ;;
            *)
                cmd="$s";
                break
            ;;
        esac;
        i="$((++i))";
    done;
    if [[ "$i" -eq "$COMP_CWORD" ]]; then
        local cmds='
'"$(brew commands --quiet --include-aliases | \grep -v instal$)";
        __brewcomp "${cmds}";
        return;
    fi;
    case "$cmd" in 
        --cache)
            __brew_complete_formulae
        ;;
        --cellar)
            __brew_complete_formulae
        ;;
        --prefix)
            __brew_complete_formulae
        ;;
        analytics)
            _brew_analytics
        ;;
        audit)
            __brew_complete_formulae
        ;;
        bottle)
            _brew_bottle
        ;;
        cask)
            _brew_cask
        ;;
        cat)
            __brew_complete_formulae
        ;;
        cleanup)
            _brew_cleanup
        ;;
        create)
            _brew_create
        ;;
        deps)
            _brew_deps
        ;;
        desc)
            _brew_desc
        ;;
        diy | configure)
            _brew_diy
        ;;
        doctor | dr)
            _brew_doctor
        ;;
        edit)
            __brew_complete_formulae
        ;;
        fetch)
            _brew_fetch
        ;;
        gist-logs)
            _brew_gist_logs
        ;;
        home | homepage)
            __brew_complete_formulae
        ;;
        info | abv)
            _brew_info
        ;;
        install | instal)
            _brew_install
        ;;
        irb)
            _brew_irb
        ;;
        link | ln)
            _brew_link
        ;;
        list | ls)
            _brew_list
        ;;
        log)
            _brew_log
        ;;
        man)
            _brew_man
        ;;
        missing)
            __brew_complete_formulae
        ;;
        options)
            _brew_options
        ;;
        outdated)
            _brew_outdated
        ;;
        pin)
            __brew_complete_formulae
        ;;
        postinstall)
            _brew_postinstall
        ;;
        prune)
            _brew_prune
        ;;
        pull)
            _brew_pull
        ;;
        readall)
            _brew_readall
        ;;
        reinstall)
            _brew_install
        ;;
        search | -S)
            _brew_search
        ;;
        style)
            _brew_style
        ;;
        switch)
            _brew_switch
        ;;
        tap)
            _brew_tap
        ;;
        tap-info)
            _brew_tap_info
        ;;
        tap-pin)
            __brew_complete_tapped
        ;;
        tap-new)
            _brew_tap_new
        ;;
        tap-unpin)
            _brew_tap_unpin
        ;;
        test)
            __brew_complete_installed
        ;;
        tests)
            _brew_tests
        ;;
        uninstall | remove | rm)
            _brew_uninstall
        ;;
        unlink)
            __brew_complete_installed
        ;;
        unpack)
            _brew_unpack
        ;;
        unpin)
            __brew_complete_formulae
        ;;
        untap)
            __brew_complete_tapped
        ;;
        update | up)
            _brew_update
        ;;
        upgrade)
            _brew_upgrade
        ;;
        uses)
            _brew_uses
        ;;
        *)

        ;;
    esac
}
_brew_analytics () 
{ 
    case "$COMP_CWORD" in 
        2)
            __brewcomp "off on regenerate-uuid state"
        ;;
    esac
}
_brew_bottle () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--merge --rb --write --root_url=";
            return
        ;;
    esac;
    __brew_complete_installed
}
_brew_cask () 
{ 
    local i=1 cmd;
    while [[ $i -lt $COMP_CWORD ]]; do
        local s="${COMP_WORDS[i]}";
        case "$s" in 
            --*)
                cmd="$s";
                break
            ;;
            -*)

            ;;
            cask)

            ;;
            *)
                cmd="$s";
                break
            ;;
        esac;
        i=$((++i));
    done;
    if [[ $i -eq $COMP_CWORD ]]; then
        __brew_caskcomp "abv audit cat cleanup create doctor edit fetch home info install list ls outdated reinstall remove rm search style uninstall upgrade zap -S --force --verbose --appdir --colorpickerdir --prefpanedir --qlplugindir --fontdir --servicedir --input_methoddir --internet_plugindir --screen_saverdir --no-binaries --debug --version";
        return;
    fi;
    case "$cmd" in 
        --version)
            __brewcomp_null
        ;;
        audit)
            __brew_cask_complete_formulae
        ;;
        cat)
            __brew_cask_complete_formulae
        ;;
        create)

        ;;
        doctor)
            __brewcomp_null
        ;;
        edit)
            __brew_cask_complete_formulae
        ;;
        fetch)
            _brew_cask_fetch
        ;;
        home)
            __brew_cask_complete_formulae
        ;;
        info | abv)
            __brew_cask_complete_formulae
        ;;
        install | instal)
            _brew_cask_install
        ;;
        list | ls)
            _brew_cask_list
        ;;
        outdated)
            _brew_cask_outdated
        ;;
        reinstall)
            __brew_cask_complete_installed
        ;;
        search)
            __brewcomp_null
        ;;
        style)
            _brew_cask_style
        ;;
        uninstall | remove | rm)
            _brew_cask_uninstall
        ;;
        upgrade)
            _brew_cask_upgrade
        ;;
        zap)
            __brew_cask_complete_caskroom
        ;;
        *)

        ;;
    esac
}
_brew_cask_fetch () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv=$(__brew_caskcomp_prev);
    case "$cur" in 
        -*)
            __brew_caskcomp "--force";
            return
        ;;
    esac;
    __brew_cask_complete_formulae
}
_brew_cask_install () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv=$(__brew_caskcomp_prev);
    case "$cur" in 
        -*)
            __brew_caskcomp "--force --skip-cask-deps --require-sha --language";
            return
        ;;
    esac;
    __brew_cask_complete_formulae
}
_brew_cask_list () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        -*)
            __brew_caskcomp "-1 --versions";
            return
        ;;
    esac;
    __brew_cask_complete_installed
}
_brew_cask_outdated () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        -*)
            __brew_caskcomp "--greedy --verbose --quiet";
            return
        ;;
    esac;
    __brew_cask_complete_installed
}
_brew_cask_style () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        -*)
            __brew_caskcomp "--fix";
            return
        ;;
    esac;
    __brew_cask_complete_installed
}
_brew_cask_uninstall () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        -*)
            __brew_caskcomp "--force";
            return
        ;;
    esac;
    __brew_cask_complete_installed
}
_brew_cask_upgrade () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        -*)
            __brew_caskcomp "--force --greedy";
            return
        ;;
    esac;
    __brew_cask_complete_outdated
}
_brew_cleanup () 
{ 
    __brew_complete_installed
}
_brew_create () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--autotools --cmake --no-fetch --set-name --set-version";
            return
        ;;
    esac
}
_brew_deps () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--1 --all --tree";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_desc () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--search --name --description";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_diy () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--set-name --set-version";
            return
        ;;
    esac
}
_brew_doctor () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    __brewcomp "$(brew doctor --list-checks)"
}
_brew_fetch () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv="$(__brewcomp_prev)";
    case "$cur" in 
        --*)
            __brewcomp "
        --deps --force
        --devel --HEAD
        --build-from-source --force-bottle --build-bottle
        --retry
        $(brew options --compact "$prv" 2>/dev/null)
        ";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_gist_logs () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--new-issue";
            return
        ;;
    esac;
    __brew_complete_logs
}
_brew_info () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--all --github --installed --json=v1";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_install () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv="$(__brewcomp_prev)";
    case "$cur" in 
        --*)
            if __brewcomp_words_include "--interactive"; then
                __brewcomp "--devel --git --HEAD";
            else
                __brewcomp "
          --build-from-source --build-bottle --force-bottle
          --debug
          --devel
          --HEAD
          --ignore-dependencies
          --interactive
          --only-dependencies
          --verbose
          --display-times
          $(brew options --compact "$prv" 2>/dev/null)
          ";
            fi;
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_irb () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--examples";
            return
        ;;
    esac
}
_brew_link () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--dry-run --overwrite --force";
            return
        ;;
    esac;
    __brew_complete_installed
}
_brew_list () 
{ 
    local allopts="--unbrewed --verbose --pinned --versions --multiple";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            if __brewcomp_words_include "--unbrewed"; then
                return;
            else
                if __brewcomp_words_include "--verbose"; then
                    return;
                else
                    if __brewcomp_words_include "--pinned"; then
                        return;
                    else
                        if __brewcomp_words_include "--multiple"; then
                            __brewcomp "--versions";
                            return;
                        else
                            if __brewcomp_words_include "--versions"; then
                                __brewcomp "--multiple";
                                return;
                            else
                                __brewcomp "$allopts";
                                return;
                            fi;
                        fi;
                    fi;
                fi;
            fi
        ;;
    esac;
    if __brewcomp_words_include "--multiple"; then
        __brewcomp "--versions";
    else
        __brew_complete_installed;
    fi
}
_brew_log () 
{ 
    declare -F _git_log > /dev/null || return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "
        $__git_log_common_options
        $__git_log_shortlog_options
        $__git_log_gitk_options
        $__git_diff_common_options
        --walk-reflogs --graph --decorate
        --abbrev-commit --oneline --reverse
        ";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_man () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--link --server --verbose";
            return
        ;;
    esac
}
_brew_options () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--all --compact --installed";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_outdated () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--quiet --json=v1 --fetch-HEAD";
            return
        ;;
    esac
}
_brew_postinstall () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--debug --sandbox";
            return
        ;;
    esac;
    __brew_complete_installed
}
_brew_prune () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--dry-run --verbose";
            return
        ;;
    esac
}
_brew_pull () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--bottle --bump --clean --ignore-whitespace --install --resolve";
            return
        ;;
    esac
}
_brew_readall () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--syntax";
            return
        ;;
    esac;
    __brew_complete_tapped
}
_brew_search () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--debian --desc --fedora --fink --macports --opensuse --ubuntu";
            return
        ;;
    esac;
    __brewcomp_null
}
_brew_style () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--fix";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_switch () 
{ 
    case "$COMP_CWORD" in 
        2)
            __brew_complete_installed
        ;;
        3)
            __brew_complete_versions "${COMP_WORDS[COMP_CWORD-1]}"
        ;;
        *)

        ;;
    esac
}
_brew_tap () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--repair --list-pinned";
            return
        ;;
    esac
}
_brew_tap_info () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--installed --json=v1";
            return
        ;;
    esac;
    __brew_complete_tapped
}
_brew_tap_new () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--verbose";
            return
        ;;
    esac
}
_brew_tap_unpin () 
{ 
    __brewcomp "$(brew tap --list-pinned)"
}
_brew_tests () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--verbose";
            return
        ;;
    esac
}
_brew_to_completion () 
{ 
    _brew
}
_brew_uninstall () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--force";
            return
        ;;
    esac;
    __brew_complete_installed
}
_brew_unpack () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--git --patch --destdir=";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_brew_update () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--rebase --verbose";
            return
        ;;
    esac
}
_brew_upgrade () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv="$(__brewcomp_prev)";
    case "$cur" in 
        --*)
            __brewcomp "
        --all
        --build-from-source --build-bottle --force-bottle
        --cleanup
        --debug
        --verbose
        --fetch-HEAD
        --display-times
        ";
            return
        ;;
    esac;
    __brew_complete_outdated
}
_brew_uses () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __brewcomp "--installed --recursive";
            return
        ;;
    esac;
    __brew_complete_formulae
}
_bzip2 () 
{ 
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in 
        -b | -h | --help | -p)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "${helpopts//#/} -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.bz2";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_cancel () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W "$( lpstat | cut -d' ' -f1 )" -- "$cur" ))
}
_cd () 
{ 
    local cur IFS='
' i j k;
    _get_comp_words_by_ref cur;
    if [[ "$cur" == ?(\\)\$* ]]; then
        COMPREPLY=($( compgen -v -P '$' -- "${cur#?(\\)$}" ));
        return 0;
    fi;
    _compopt_o_filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j="${j}/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_chgrp () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    cur=${cur//\\\\/};
    _split_longopt && split=true;
    if [[ "$prev" == --reference ]]; then
        _filedir;
        return 0;
    fi;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
        return 0;
    fi;
    if [[ $COMP_CWORD -eq 1 && "$cur" != -* || "$prev" == -* ]]; then
        _allowed_groups;
    else
        _filedir || return 0;
    fi;
    return 0
}
_chown () 
{ 
    local cur prev split=false;
    _get_comp_words_by_ref -n : cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --from)
            _usergroup;
            return 0
        ;;
        --reference)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --from --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
    else
        local args;
        _count_args :;
        if [[ $args == 1 ]]; then
            _usergroup -u;
        else
            _filedir;
        fi;
    fi
}
_chsh () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --list-shells | --help | -v | --version)
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* && "$( uname -s )" == @(Linux|GNU|GNU/*) ]]; then
        COMPREPLY=($( compgen -W '--shell --list-shells --help --version'             -- "$cur" ));
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local cur func cline cspec noglob cmd i char_offset word_offset _COMMAND_FUNC _COMMAND_FUNC_ARGS;
    word_offset=$1;
    local first_word=${COMP_WORDS[$word_offset]};
    for ((i=0; i <= ${#COMP_LINE}; i++ ))
    do
        if [[ "${COMP_LINE:$i:${#first_word}}" == "$first_word" ]]; then
            char_offset=$i;
            break;
        fi;
    done;
    COMP_LINE=${COMP_LINE:$char_offset};
    COMP_POINT=$(( COMP_POINT - $char_offset ));
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    COMP_CWORD=$(( $COMP_CWORD - $word_offset ));
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -c -- "$cur" ));
    else
        cmd=${COMP_WORDS[0]};
        if complete -p ${cmd##*/} >&/dev/null; then
            cspec=$( complete -p ${cmd##*/} );
            if [ "${cspec#* -F }" != "$cspec" ]; then
                func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                if [ "${cspec#*-o }" != "$cspec" ]; then
                    cspec=${cspec#*-o };
                    cspec=${cspec%% *};
                    if [[ "$cspec" != @(dir|file)names ]]; then
                        COMPREPLY=("${COMPREPLY[@]//\\\\:/:}");
                    else
                        _compopt_o_filenames;
                    fi;
                fi;
            else
                if [ -n "$cspec" ]; then
                    cspec=${cspec#complete};
                    cspec=${cspec%%${cmd##*/}};
                    COMPREPLY=($( eval compgen "$cspec" -- "$cur" ));
                fi;
            fi;
        else
            if [ ${#COMPREPLY[@]} -eq 0 ]; then
                _filedir;
            fi;
        fi;
    fi
}
_complete () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o)
            COMPREPLY=($( compgen -W 'bashdefault default dirnames filenames \
                nospace plusdirs' -- "$cur" ));
            return 0
        ;;
        -A)
            COMPREPLY=($( compgen -W 'alias arrayvar binding builtin command \
                directory disabled enabled export file function group \
                helptopic hostname job keyword running service setopt shopt \
                signal stopped user variable' -- "$cur" ));
            return 0
        ;;
        -C)
            COMPREPLY=($( compgen -A command -- "$cur" ));
            return 0
        ;;
        -F)
            COMPREPLY=($( compgen -A function -- "$cur" ));
            return 0
        ;;
        -p | -r)
            COMPREPLY=($( complete -p | sed -e 's|.* ||' ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        local opts="-a -b -c -d -e -f -g -j -k -o -s -u -v -A -G -W -P -S -X";
        [[ $1 != compgen ]] && opts="$opts -F -C";
        COMPREPLY=($( compgen -W "$opts" -- "$cur" ));
    else
        COMPREPLY=($( compgen -A command -- "$cur" ));
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_compopt_o_filenames () 
{ 
    type compopt >&/dev/null && compopt -o filenames 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null
}
_configure () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        --*prefix | --*dir)
            _filedir -d
        ;;
    esac;
    $split && return 0;
    [[ "$cur" != -* ]] && return 0;
    if [ -n "$COMP_CONFIGURE_HINTS" ]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,].*//g' )"             -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,=].*//g' )"             -- "$cur" ));
    fi
}
_configured_interfaces () 
{ 
    if [ -f /etc/debian_version ]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [ -f /etc/SuSE-release ]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [ -f /etc/pld-release ]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cowsay () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -f)
            COMPREPLY=($( compgen -W '$( cowsay -l | tail -n +2)' -- "$cur" ));
            return 0
        ;;
    esac;
    COMPREPLY=($( compgen -W '-b -d -g -p -s -t -w -y -e -f -h -l -n -T -W'         -- "$cur" ))
}
_cpan2dist () 
{ 
    local cur prev packagelist cpandirs;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --format)
            COMPREPLY=($( compgen -W '$(perl -MCPANPLUS::Dist -e \
                "print map { \"\$_\n\" } CPANPLUS::Dist->dist_types")'                 -- "$cur" ));
            return 0
        ;;
        --banlist | --ignorelist | --modulelist | --logfile)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--help --skiptest --force --install \
            --verbose --keepsource --makefile --buildprereq \
            --archive --flushcache --defaults --edit-metafile \
            --format --ban --banlist --ignore --ignorelist \
            --modulelist --logfile --timeout --set-config \
            --set-program --dist-opts --default-banlist \
            --default-ignorelist' -- $cur ));
    else
        cpandirs=("$HOME/.cpanplus/" "$HOME/.cpan/source/modules/");
        for dir in ${cpandirs[@]};
        do
            [[ -d "$dir" && -r "$dir/02packages.details.txt.gz" ]] && packagelist="$dir/02packages.details.txt.gz";
        done;
        COMPREPLY=($( zgrep "^${cur//-/::}"             $packagelist 2>/dev/null             | awk '{print $1}' | sed -e 's/::/-/g' ));
    fi
}
_cpio () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _split_longopt && split=true;
    case $prev in 
        -H | --format)
            _cpio_format;
            return 0
        ;;
        -E | -F | -I | --file | --pattern-file)
            _filedir;
            return 0
        ;;
        -R | --owner)
            _usergroup;
            return 0
        ;;
        --rsh-command)
            _compopt_o_filenames;
            COMPREPLY=($( compgen -c -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W '-o --create -i --extract -p --pass-through \
                                   -? --help --license --usage --version' -- "$cur" ));
    else
        case ${COMP_WORDS[1]} in 
            -o | --create)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -c -v -A -B\
                        -L -V -C -H -M -O -F --file --format\
                        --message --null --reset-access-time\
                        --verbose --dot --append --block-size\
                        --dereference --io-size --quiet\
                        --force-local --rsh-command --help\
                        --version' -- "$cur" ));
                fi
            ;;
            -i | --extract)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-b -c -d -f -m -n -r\
                        -t -s -u -v -B -S -V -C -E -H -M -R -I\
                        -F --file --make-directories\
                        --nonmatching\
                        --preserve-modification-time\
                        --numeric-uid-gid --rename -t --list\
                        --swap-bytes --swap --dot\
                        --unconditional --verbose --block-size\
                        --swap-halfwords --io-size\
                        --pattern-file --format --owner\
                        --no-preserve-owner --message\
                        --force-local --no-absolute-filenames\
                        --sparse --only-verify-crc --quiet\
                        --rsh-command --help\
                        --to-stdout \
                        --version' -- "$cur" ));
                fi
            ;;
            -p | --pass-through)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -d -l -m -u -v\
                        -L -V -R --null --reset-access-time\
                        --make-directories --link --quiet\
                        --preserve-modification-time\
                        --unconditional --verbose --dot\
                        --dereference --owner\
                        --no-preserve-owner --sparse --help\
                        --version' -- "$cur" ));
                else
                    _filedir -d;
                fi
            ;;
        esac;
    fi
}
_cpio_format () 
{ 
    COMPREPLY=($( compgen -W 'bin odc newc crc tar ustar hpbin hpodc' -- "$cur" ))
}
_crontab () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -u)
            _allowed_users;
            return 0
        ;;
    esac;
    local i opts=" -u -l -r -e";
    [ "$(uname -s)" = Linux ] && opts="$opts -i";
    [ -e /etc/selinux ] && opts="$opts -s";
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case "${COMP_WORDS[i]}" in 
            -l)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/};
                opts=${opts// -s/}
            ;;
            -e)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/}
            ;;
            -r)
                opts=${opts// -l -r -e/}
            ;;
            -u)
                opts=${opts// -u/};
                opts=${opts// -i/}
            ;;
            -i | -s)
                opts=${opts// ${COMP_WORDS[i]}/}
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$opts' -- "$cur" ));
        return 0;
    fi;
    [[ "${COMP_LINE}" == *\ -@(l|r|e)* ]] || _filedir
}
_cryptsetup_device () 
{ 
    cur=${cur:=/dev/};
    _filedir
}
_cryptsetup_name () 
{ 
    COMPREPLY=($( compgen -X control -W '$( command ls /dev/mapper )'         -- "$cur" ))
}
_dd () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n = cur;
    case $cur in 
        if=* | of=*)
            cur=${cur#*=};
            _filedir;
            return 0
        ;;
        conv=*)
            cur=${cur#*=};
            COMPREPLY=($( compgen -W 'ascii ebcdic ibm block unblock lcase
                notrunc ucase swab noerror sync' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    COMPREPLY=($( compgen -W '--help --version' -- "$cur" ) $( compgen -W 'bs cbs conv count ibs if obs of seek skip'                            -S '=' -- "$cur" ))
}
_docker () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local management_commands=(config container image network node plugin secret service stack swarm system trust volume);
    local top_level_commands=(build login logout run search version);
    local legacy_commands=(attach commit cp create diff events exec export history images import info inspect kill load logs pause port ps pull push rename restart rm rmi save start stats stop tag top unpause update wait);
    local experimental_commands=(checkpoint deploy);
    local commands=(${management_commands[*]} ${top_level_commands[*]});
    [ -z "$DOCKER_HIDE_LEGACY_COMMANDS" ] && commands+=(${legacy_commands[*]});
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local host config daemon_os;
    local stack_orchestrator_is_kubernetes stack_orchestrator_is_swarm;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in 
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local binary="${words[0]}";
    if [[ $binary == ?(*/)dockerd ]]; then
        command=daemon;
        command_pos=0;
    fi;
    local completions_func=_docker_${command//-/_};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach () 
{ 
    _docker_container_attach
}
_docker_build () 
{ 
    _docker_image_build
}
_docker_checkpoint () 
{ 
    local subcommands="
		create
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint_create () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help --leave-running" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_checkpoint_ls () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_checkpoint_rm () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    COMPREPLY=($( compgen -W "$(__docker_q checkpoint ls "$prev" | sed 1d)" -- "$cur" ));
                fi;
            fi
        ;;
    esac
}
_docker_commit () 
{ 
    _docker_container_commit
}
_docker_config () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_config_create () 
{ 
    case "$prev" in 
        --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_config_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_config_list () 
{ 
    _docker_config_ls
}
_docker_config_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_configs --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_configs --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_config_remove () 
{ 
    _docker_config_rm
}
_docker_config_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_container () 
{ 
    local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	";
    local aliases="
		list
		ps
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_container_attach () 
{ 
    __docker_complete_detach_keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_container_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--archive -a --follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "${COMPREPLY[*]}" = *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ "$cword" -eq "$counter" ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_container_create () 
{ 
    _docker_container_run_and_create
}
_docker_container_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_exec () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --env -e --help --interactive -i --privileged -t --tty -u --user --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_export () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_inspect () 
{ 
    _docker_inspect --type container
}
_docker_container_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_list () 
{ 
    _docker_container_ls
}
_docker_container_logs () 
{ 
    case "$prev" in 
        --since | --tail | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --since --tail --timestamps -t --until" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|--until');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        ancestor)
            __docker_complete_images --cur "${cur##*=}" --repo --tag --id;
            return
        ;;
        before)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        expose | publish)
            return
        ;;
        id)
            __docker_complete_containers_all --cur "${cur##*=}" --id;
            return
        ;;
        health)
            COMPREPLY=($( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ));
            return
        ;;
        is-task)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_containers_all --cur "${cur##*=}" --name;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        since)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor before exited expose health id is-task label name network publish since status volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --last | -n)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ))
        ;;
    esac
}
_docker_container_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_container_ps () 
{ 
    _docker_container_ls
}
_docker_container_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_removable
        ;;
    esac
}
_docker_container_run () 
{ 
    _docker_container_run_and_create
}
_docker_container_run_and_create () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-cgroup-rule
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--entrypoint
		--env -e
		--env-file
		--expose
		--group-add
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname -h
		--ip
		--ip6
		--ipc
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--mount
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--publish -p
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    __docker_daemon_os_is windows && options_with_args+="
		--cpu-count
		--cpu-percent
		--io-maxbandwidth
		--io-maxiops
		--isolation
	";
    __docker_daemon_is_experimental && options_with_args+="
		--platform
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--init
		--interactive -i
		--no-healthcheck
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ] || [ "$subcommand" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach_keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    __docker_complete_log_driver_options && return;
    __docker_complete_restart && return;
    local key=$(__docker_map_key_of_current_option '--security-opt');
    case "$key" in 
        label)
            [[ $cur == *: ]] && return;
            COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "${cur##*=}"));
            if [ "${COMPREPLY[*]}" != "disable" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        seccomp)
            local cur=${cur##*=};
            _filedir;
            COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ));
            return
        ;;
    esac;
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'none host private shareable container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            if __docker_daemon_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pid)
            case "$cur" in 
                *:*)
                    __docker_complete_containers_running --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --runtime)
            __docker_complete_runtimes;
            return
        ;;
        --security-opt)
            COMPREPLY=($( compgen -W "apparmor= label= no-new-privileges seccomp=" -- "$cur"));
            if [ "${COMPREPLY[*]}" != "no-new-privileges" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --storage-opt)
            COMPREPLY=($( compgen -W "size" -S = -- "$cur"));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --userns)
            COMPREPLY=($( compgen -W "host" -- "$cur" ));
            return
        ;;
        --volume-driver)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag --id;
            fi
        ;;
    esac
}
_docker_container_start () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --checkpoint)
            if __docker_daemon_is_experimental; then
                return;
            fi
        ;;
        --checkpoint-dir)
            if __docker_daemon_is_experimental; then
                _filedir -d;
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--attach -a --detach-keys --help --interactive -i";
            __docker_daemon_is_experimental && options+=" --checkpoint --checkpoint-dir";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_stats () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --format --help --no-stream --no-trunc" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_container_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpus
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--restart
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    __docker_complete_restart && return;
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_cp () 
{ 
    _docker_container_cp
}
_docker_create () 
{ 
    _docker_container_create
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--experimental
		--help
		--icc=false
		--init
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ipv6
		--live-restore
		--no-new-privileges
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
		--version -v
	";
    local options_with_args="
		$global_options_with_args
		--add-runtime
		--allow-nondistributable-artifacts
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--config-file
		--containerd
		--cpu-rt-period
		--cpu-rt-runtime
		--data-root
		--default-address-pool
		--default-gateway
		--default-gateway-v6
		--default-runtime
		--default-shm-size
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--metrics-addr
		--mtu
		--network-control-plane-mtu
		--node-generic-resource
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--swarm-default-advertise-addr
		--userland-proxy-path
		--userns-remap
	";
    __docker_complete_log_driver_options && return;
    key=$(__docker_map_key_of_current_option '--cluster-store-opt');
    case "$key" in 
        kv.*file)
            cur=${cur##*=};
            _filedir;
            return
        ;;
    esac;
    local key=$(__docker_map_key_of_current_option '--storage-opt');
    case "$key" in 
        dm.blkdiscard | dm.override_udev_sync_check | dm.use_deferred_removal | dm.use_deferred_deletion)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        dm.directlvm_device | dm.thinpooldev)
            cur=${cur##*=};
            _filedir;
            return
        ;;
        dm.fs)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur##*=}" ));
            return
        ;;
        dm.libdm_log_level)
            COMPREPLY=($( compgen -W "2 3 4 5 6 7" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins_bundled --type Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --config-file | --containerd | --init-path | --pidfile | -p | --tlscacert | --tlscert | --tlskey | --userland-proxy-path)
            _filedir;
            return
        ;;
        --exec-root | --data-root)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs devicemapper overlay overlay2 vfs zfs" -- "$(echo "$cur" | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local btrfs_options="btrfs.min_space";
            local devicemapper_options="
				dm.basesize
				dm.blkdiscard
				dm.blocksize
				dm.directlvm_device
				dm.fs
				dm.libdm_log_level
				dm.loopdatasize
				dm.loopmetadatasize
				dm.min_free_space
				dm.mkfsarg
				dm.mountopt
				dm.override_udev_sync_check
				dm.thinpooldev
				dm.thinp_autoextend_percent
				dm.thinp_autoextend_threshold
				dm.thinp_metapercent
				dm.thinp_percent
				dm.use_deferred_deletion
				dm.use_deferred_removal
			";
            local overlay2_options="overlay2.size";
            local zfs_options="zfs.fsname";
            local all_options="$btrfs_options $devicemapper_options $overlay2_options $zfs_options";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
                ;;
                btrfs)
                    COMPREPLY=($( compgen -W "$btrfs_options" -S = -- "$cur" ))
                ;;
                devicemapper)
                    COMPREPLY=($( compgen -W "$devicemapper_options" -S = -- "$cur" ))
                ;;
                overlay2)
                    COMPREPLY=($( compgen -W "$overlay2_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --metrics-addr)
            __docker_complete_local_ips;
            __docker_append_to_completions ":";
            __docker_nospace;
            return
        ;;
        --seccomp-profile)
            _filedir json;
            return
        ;;
        --swarm-default-advertise-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --userns-remap)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_deploy () 
{ 
    __docker_daemon_is_experimental && _docker_stack_deploy
}
_docker_diff () 
{ 
    _docker_container_diff
}
_docker_docker () 
{ 
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in 
        --config)
            _filedir -d;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$(__docker_to_extglob "$global_options_with_args")" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_daemon_is_experimental && commands+=(${experimental_commands[*]});
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events () 
{ 
    _docker_system_events
}
_docker_exec () 
{ 
    _docker_container_exec
}
_docker_export () 
{ 
    _docker_container_export
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ "$cword" -eq "$counter" ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    _docker_image_history
}
_docker_image () 
{ 
    local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	";
    local aliases="
		images
		list
		remove
		rmi
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_image_build () 
{ 
    local options_with_args="
		--add-host
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--iidfile
		--label
		--memory -m
		--memory-swap
		--network
		--shm-size
		--tag -t
		--target
		--ulimit
	";
    __docker_daemon_os_is windows && options_with_args+="
		--isolation
	";
    local boolean_options="
		--compress
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    if __docker_daemon_is_experimental; then
        options_with_args+="
			--platform
		";
        boolean_options+="
			--squash
			--stream
		";
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cache-from)
            __docker_complete_images --repo --tag --id;
            return
        ;;
        --file | -f | --iidfile)
            _filedir;
            return
        ;;
        --isolation)
            if __docker_daemon_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --tag | -t)
            __docker_complete_images --repo --tag;
            return
        ;;
        --target)
            local context_pos=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            local context="${words[$context_pos]}";
            context="${context:-.}";
            local file="$( __docker_value_of_option '--file|f' )";
            local default_file="${context%/}/Dockerfile";
            local dockerfile="${file:-$default_file}";
            local targets="$( sed -n 's/^FROM .\+ AS \(.\+\)/\1/p' "$dockerfile" 2>/dev/null )";
            COMPREPLY=($( compgen -W "$targets" -- "$cur" ));
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_image_history () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_image_images () 
{ 
    _docker_image_ls
}
_docker_image_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--change -c --help --message -m" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                _filedir;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_image_inspect () 
{ 
    _docker_inspect --type image
}
_docker_image_list () 
{ 
    _docker_image_ls
}
_docker_image_load () 
{ 
    case "$prev" in 
        --input | -i | "<")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_image_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        before | since)
            __docker_complete_images --cur "${cur##*=}" --force-tag --id;
            return
        ;;
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        label)
            return
        ;;
        reference)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "before dangling label reference since" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_images --repo --tag
        ;;
    esac
}
_docker_image_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_image_pull () 
{ 
    case "$prev" in 
        --platform)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--all-tags -a --disable-content-trust=false --help";
            __docker_daemon_is_experimental && options+=" --platform";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag --platform);
            if [ "$cword" -eq "$counter" ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_images --repo;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_remove () 
{ 
    _docker_image_rm
}
_docker_image_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_image_rmi () 
{ 
    _docker_image_rm
}
_docker_image_save () 
{ 
    case "$prev" in 
        --output | -o | ">")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --repo --tag --id
        ;;
    esac
}
_docker_image_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    _docker_image_ls
}
_docker_import () 
{ 
    _docker_image_import
}
_docker_info () 
{ 
    _docker_system_info
}
_docker_inspect () 
{ 
    local preselected_type;
    local type;
    if [ "$1" = "--type" ]; then
        preselected_type=yes;
        type="$2";
    else
        type=$(__docker_value_of_option --type);
    fi;
    case "$prev" in 
        --format | -f)
            return
        ;;
        --type)
            if [ -z "$preselected_type" ]; then
                COMPREPLY=($( compgen -W "container image network node plugin secret service volume" -- "$cur" ));
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format -f --help --size -s";
            if [ -z "$preselected_type" ]; then
                options+=" --type";
            fi;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            case "$type" in 
                '')
                    COMPREPLY=($( compgen -W "
						$(__docker_containers --all)
						$(__docker_images --force-tag --id)
						$(__docker_networks)
						$(__docker_nodes)
						$(__docker_plugins_installed)
						$(__docker_secrets)
						$(__docker_services)
						$(__docker_volumes)
					" -- "$cur" ));
                    __ltrim_colon_completions "$cur"
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images --force-tag --id
                ;;
                network)
                    __docker_complete_networks
                ;;
                node)
                    __docker_complete_nodes
                ;;
                plugin)
                    __docker_complete_plugins_installed
                ;;
                secret)
                    __docker_complete_secrets
                ;;
                service)
                    __docker_complete_services
                ;;
                volume)
                    __docker_complete_volumes
                ;;
            esac
        ;;
    esac
}
_docker_kill () 
{ 
    _docker_container_kill
}
_docker_load () 
{ 
    _docker_image_load
}
_docker_login () 
{ 
    case "$prev" in 
        --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --password -p --password-stdin --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    _docker_container_logs
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --ip-range | --ipam-opt | --ipv6 | --opt | -o | --subnet)
            return
        ;;
        --config-from)
            __docker_complete_networks;
            return
        ;;
        --driver | -d)
            __docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan;
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --label)
            return
        ;;
        --scope)
            COMPREPLY=($( compgen -W "local swarm" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attachable --aux-address --config-from --config-only --driver -d --gateway --help --ingress --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --scope --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --verbose" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan;
            return
        ;;
        id)
            __docker_complete_networks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_networks --cur "${cur##*=}" --name;
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "global local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "driver id label name scope type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks --filter type=custom
        ;;
    esac
}
_docker_node () 
{ 
    local subcommands="
		demote
		inspect
		ls
		promote
		rm
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_node_demote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=manager
        ;;
    esac
}
_docker_node_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_list () 
{ 
    _docker_node_ls
}
_docker_node_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_nodes --cur "${cur##*=}" --id;
            return
        ;;
        membership)
            COMPREPLY=($( compgen -W "accepted pending" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_nodes --cur "${cur##*=}" --name;
            return
        ;;
        role)
            COMPREPLY=($( compgen -W "manager worker" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label membership name role" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_node_promote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=worker
        ;;
    esac
}
_docker_node_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_remove () 
{ 
    _docker_node_rm
}
_docker_node_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_node_update () 
{ 
    case "$prev" in 
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --role)
            COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            return
        ;;
        --label-add | --label-rm)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--availability|--label-add|--label-rm|--role');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_nodes;
            fi
        ;;
    esac
}
_docker_pause () 
{ 
    _docker_container_pause
}
_docker_plugin () 
{ 
    local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
		upgrade
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--compress --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir -d;
                fi;
            fi
        ;;
    esac
}
_docker_plugin_disable () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=true;
            fi
        ;;
    esac
}
_docker_plugin_enable () 
{ 
    case "$prev" in 
        --timeout)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--timeout');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=false;
            fi
        ;;
    esac
}
_docker_plugin_inspect () 
{ 
    case "$prev" in 
        --format | f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_install () 
{ 
    case "$prev" in 
        --alias)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--alias --disable --disable-content-trust=false --grant-all-permissions --help" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_list () 
{ 
    _docker_plugin_ls
}
_docker_plugin_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        capability)
            COMPREPLY=($( compgen -W "authz ipamdriver logdriver metricscollector networkdriver volumedriver" -- "${cur##*=}" ));
            return
        ;;
        enabled)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "capability enabled" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_remove () 
{ 
    _docker_plugin_rm
}
_docker_plugin_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_set () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_upgrade () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust --grant-all-permissions --help --skip-remote-check" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
                __ltrim_colon_completions "$cur";
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    local plugin_images="$(__docker_plugins_installed)";
                    COMPREPLY=($(compgen -S : -W "${plugin_images%:*}" -- "$cur"));
                    __docker_nospace;
                fi;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    _docker_container_port
}
_docker_ps () 
{ 
    _docker_container_ls
}
_docker_pull () 
{ 
    _docker_image_pull
}
_docker_push () 
{ 
    _docker_image_push
}
_docker_rename () 
{ 
    _docker_container_rename
}
_docker_restart () 
{ 
    _docker_container_restart
}
_docker_rm () 
{ 
    _docker_container_rm
}
_docker_rmi () 
{ 
    _docker_image_rm
}
_docker_run () 
{ 
    _docker_container_run
}
_docker_save () 
{ 
    _docker_image_save
}
_docker_search () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        is-automated)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        is-official)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "is-automated is-official stars" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --limit --no-trunc" -- "$cur" ))
        ;;
    esac
}
_docker_secret () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_secret_create () 
{ 
    case "$prev" in 
        --driver | -d | --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--driver|-d|--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_secret_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_list () 
{ 
    _docker_secret_ls
}
_docker_secret_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_secrets --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_secrets --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_secret_remove () 
{ 
    _docker_secret_rm
}
_docker_secret_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_service () 
{ 
    local subcommands="
		create
		inspect
		logs
		ls
		rm
		rollback
		scale
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_service_create () 
{ 
    _docker_service_update_and_create
}
_docker_service_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_list () 
{ 
    _docker_service_ls
}
_docker_service_logs () 
{ 
    case "$prev" in 
        --since | --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --no-resolve --no-task-ids --no-trunc --raw --since --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services_and_tasks;
            fi
        ;;
    esac
}
_docker_service_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "global replicated" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label mode name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_service_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}" --add self;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id name node" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_remove () 
{ 
    _docker_service_rm
}
_docker_service_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_rollback () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help --quit -q" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services;
            fi
        ;;
    esac
}
_docker_service_scale () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services;
            __docker_append_to_completions "=";
            __docker_nospace
        ;;
    esac
}
_docker_service_update () 
{ 
    _docker_service_update_and_create
}
_docker_service_update_and_create () 
{ 
    local options_with_args="
		--endpoint-mode
		--entrypoint
		--force
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname
		--isolation
		--limit-cpu
		--limit-memory
		--log-driver
		--log-opt
		--replicas
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback-delay
		--rollback-failure-action
		--rollback-max-failure-ratio
		--rollback-monitor
		--rollback-order
		--rollback-parallelism
		--stop-grace-period
		--stop-signal
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-order
		--update-parallelism
		--user -u
		--workdir -w
	";
    __docker_daemon_os_is windows && options_with_args+="
		--credential-spec
	";
    local boolean_options="
		--detach -d
		--help
		--init
		--no-healthcheck
		--read-only
		--tty -t
		--with-registry-auth
	";
    __docker_complete_log_driver_options && return;
    if [ "$subcommand" = "create" ]; then
        options_with_args="$options_with_args
			--config
			--constraint
			--container-label
			--dns
			--dns-option
			--dns-search
			--env -e
			--env-file
			--generic-resource
			--group
			--host
			--label -l
			--mode
			--mount
			--name
			--network
			--placement-pref
			--publish -p
			--secret
		";
        case "$prev" in 
            --env-file)
                _filedir;
                return
            ;;
            --mode)
                COMPREPLY=($( compgen -W "global replicated" -- "$cur" ));
                return
            ;;
        esac;
    fi;
    if [ "$subcommand" = "update" ]; then
        options_with_args="$options_with_args
			--args
			--config-add
			--config-rm
			--constraint-add
			--constraint-rm
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--env-add
			--env-rm
			--generic-resource-add
			--generic-resource-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--label-add
			--label-rm
			--mount-add
			--mount-rm
			--network-add
			--network-rm
			--placement-pref-add
			--placement-pref-rm
			--publish-add
			--publish-rm
			--rollback
			--secret-add
			--secret-rm
		";
        case "$prev" in 
            --env-rm)
                COMPREPLY=($( compgen -e -- "$cur" ));
                return
            ;;
            --image)
                __docker_complete_images --repo --tag --id;
                return
            ;;
        esac;
    fi;
    local strategy=$(__docker_map_key_of_current_option '--placement-pref|--placement-pref-add|--placement-pref-rm');
    case "$strategy" in 
        spread)
            COMPREPLY=($( compgen -W "engine.labels node.labels" -S . -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$prev" in 
        --config | --config-add | --config-rm)
            __docker_complete_configs;
            return
        ;;
        --endpoint-mode)
            COMPREPLY=($( compgen -W "dnsrr vip" -- "$cur" ));
            return
        ;;
        --env | -e | --env-add)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --group | --group-add | --group-rm)
            COMPREPLY=($(compgen -g -- "$cur"));
            return
        ;;
        --host | --host-add | --host-rm)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network | --network-add | --network-rm)
            __docker_complete_networks;
            return
        ;;
        --placement-pref | --placement-pref-add | --placement-pref-rm)
            COMPREPLY=($( compgen -W "spread" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --restart-condition)
            COMPREPLY=($( compgen -W "any none on-failure" -- "$cur" ));
            return
        ;;
        --rollback-failure-action)
            COMPREPLY=($( compgen -W "continue pause" -- "$cur" ));
            return
        ;;
        --secret | --secret-add | --secret-rm)
            __docker_complete_secrets;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --update-failure-action)
            COMPREPLY=($( compgen -W "continue pause rollback" -- "$cur" ));
            return
        ;;
        --update-order | --rollback-order)
            COMPREPLY=($( compgen -W "start-first stop-first" -- "$cur" ));
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$subcommand" = "update" ]; then
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_services;
                fi;
            else
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_images --repo --tag --id;
                fi;
            fi
        ;;
    esac
}
_docker_stack () 
{ 
    local subcommands="
		deploy
		ls
		ps
		rm
		services
	";
    local aliases="
		down
		list
		remove
		up
	";
    __docker_complete_stack_orchestrator_options && return;
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_stack_deploy () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --bundle-file)
            _filedir dab;
            return
        ;;
        --compose-file | -c)
            _filedir yml;
            return
        ;;
        --resolve-image)
            COMPREPLY=($( compgen -W "always changed never" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--compose-file -c --help --orchestrator";
            __docker_daemon_is_experimental && __docker_stack_orchestrator_is swarm && options+=" --bundle-file";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            __docker_stack_orchestrator_is swarm && options+=" --prune --resolve-image --with-registry-auth";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--bundle-file|--compose-file|-c|--kubeconfig|--namespace|--orchestrator|--resolve-image');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_down () 
{ 
    _docker_stack_rm
}
_docker_stack_list () 
{ 
    _docker_stack_ls
}
_docker_stack_ls () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format --help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_stack_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        id)
            __docker_complete_stacks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_stacks --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name desired-state" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --no-resolve --no-trunc --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--all-namespaces|--filter|-f|--format|--kubeconfig|--namespace');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_remove () 
{ 
    _docker_stack_rm
}
_docker_stack_rm () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_stacks
        ;;
    esac
}
_docker_stack_services () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        label)
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f|--format|--kubeconfig|--namespace|--orchestrator');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_up () 
{ 
    _docker_stack_deploy
}
_docker_start () 
{ 
    _docker_container_start
}
_docker_stats () 
{ 
    _docker_container_stats
}
_docker_stop () 
{ 
    _docker_container_stop
}
_docker_swarm () 
{ 
    local subcommands="
		ca
		init
		join
		join-token
		leave
		unlock
		unlock-key
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_ca () 
{ 
    case "$prev" in 
        --ca-cert | --ca-key)
            _filedir;
            return
        ;;
        --cert-expiry | --external-ca)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--ca-cert --ca-key --cert-expiry --detach -d --external-ca --help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_init () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --autolock --availability --cert-expiry --data-path-addr --dispatcher-heartbeat --external-ca --force-new-cluster --help --listen-addr --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_join () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
        --token)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --availability --data-path-addr --help --listen-addr --token" -- "$cur" ))
        ;;
        *:)
            COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ))
        ;;
    esac
}
_docker_swarm_join_token () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_swarm_leave () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock_key () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_update () 
{ 
    case "$prev" in 
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--autolock --cert-expiry --dispatcher-heartbeat --external-ca --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_system () 
{ 
    local subcommands="
		df
		events
		info
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_system_df () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --verbose -v" -- "$cur" ))
        ;;
    esac
}
_docker_system_events () 
{ 
    local key=$(__docker_map_key_of_current_option '-f|--filter');
    case "$key" in 
        container)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        daemon)
            local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p');
            COMPREPLY=($( compgen -W "$name" -- "${cur##*=}" ));
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disable
				disconnect
				enable
				exec_create
				exec_detach
				exec_die
				exec_start
				export
				health_status
				import
				install
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				remove
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "config container daemon image network plugin secret service volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container daemon event image label network scope type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until --format" -- "$cur" ))
        ;;
    esac
}
_docker_system_info () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_system_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help --volumes" -- "$cur" ))
        ;;
    esac
}
_docker_tag () 
{ 
    _docker_image_tag
}
_docker_top () 
{ 
    _docker_container_top
}
_docker_trust () 
{ 
    local subcommands="
		inspect
		revoke
		sign
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_trust_inspect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --pretty" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_revoke () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --yes -y" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_sign () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --local" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_unpause () 
{ 
    _docker_container_unpause
}
_docker_update () 
{ 
    _docker_container_update
}
_docker_version () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format -f --help";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --label | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_list () 
{ 
    _docker_volume_ls
}
_docker_volume_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        dangling)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume;
            return
        ;;
        name)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label!" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume_remove () 
{ 
    _docker_volume_rm
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    _docker_container_wait
}
_dvd_devices () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_edquota () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
        -f | --filesystem)
            _filesystems;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r --remote -m --no-mixed-pathnames \
            -g --group -u --user -p --prototype -F --format -f --filesystem \
            -t --edit-period -T --edit-times' -- "$cur" ));
    else
        _user_or_group;
    fi
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [ ${#COMPREPLY[@]} -eq 1 ] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_export () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in 
        *=\$*)
            COMPREPLY=($( compgen -v -P '$' -- "${cur#*=\$}" ))
        ;;
        *[^=])
            COMPREPLY=($( compgen -v -S '=' -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( eval echo -n \"$`echo ${cur%=}`\" |
                ( echo -n \'
                  sed -e 's/'\''/'\''\\\'\'''\''/g'
                  echo -n \' ) )")
        ;;
    esac
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted tmp;
    _quote_readline_by_ref "$cur" quoted;
    toks=(${toks[@]-} $(
        compgen -d -- "$cur" | {
            while read -r tmp; do
                # TODO: I have removed a "[ -n $tmp ] &&" before 'printf ..',
                #       and everything works again. If this bug suddenly
                #       appears again (i.e. "cd /b<TAB>" becomes "cd /"),
                #       remember to check for other similar conditionals (here
                #       and _filedir_xspec()). --David
                printf '%s\n' $tmp
            done
        }
    ));
    if [[ "$1" != -d ]]; then
        [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec=${1:+"!*.@($1|${1^^})"} || xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"};
        toks=(${toks[@]-} $( compgen -f -X "$xspec" -- $quoted));
    fi;
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${COMPREPLY[@]}" "${toks[@]}")
}
_filedir_xspec () 
{ 
    local IFS cur xspec;
    IFS='
';
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    xspec=$( awk "/^complete[ \t]+.*[ \t]${1##*/}([ \t]|\$)/ { print \$0; exit }"         "$BASH_COMPLETION" );
    xspec=${xspec#*-X };
    xspec=${xspec%% *};
    local -a toks;
    local tmp;
    toks=(${toks[@]-} $(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            # see long TODO comment in _filedir() --David
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec="$matchop($xspec|${xspec^^})" || xspec="$matchop($xspec|$(printf %s $xspec | tr '[:lower:]' '[:upper:]'))";
    toks=(${toks[@]-} $(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [ -n $tmp ] && printf '%s\n' $tmp
        done
        }
        ));
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${toks[@]}")
}
_filesystems () 
{ 
    COMPREPLY=($( compgen -W "$(awk '/^\// {print $1}' /etc/mtab)"         -- "$cur" ))
}
_find () 
{ 
    local cur prev i exprfound onlyonce;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -maxdepth | -mindepth)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -newer | -anewer | -cnewer | -fls | -fprint | -fprint0 | -fprintf | -name | -iname | -lname | -ilname | -wholename | -iwholename | -samefile)
            _filedir;
            return 0
        ;;
        -fstype)
            _fstypes;
            if [[ "$( uname -s )" == *BSD ]]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'local rdonly' -- "$cur" ));
            fi;
            return 0
        ;;
        -gid)
            _gids;
            return 0
        ;;
        -group)
            COMPREPLY=($( compgen -g -- "$cur" 2>/dev/null));
            return 0
        ;;
        -xtype | -type)
            COMPREPLY=($( compgen -W 'b c d p f l s' -- "$cur" ));
            return 0
        ;;
        -uid)
            _uids;
            return 0
        ;;
        -user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -exec | -execdir | -ok | -okdir)
            COMP_WORDS=(COMP_WORDS[0] "$cur");
            COMP_CWORD=1;
            _command;
            return 0
        ;;
        -[acm]min | -[acm]time | -iname | -lname | -wholename | -iwholename | -lwholename | -ilwholename | -inum | -path | -ipath | -regex | -iregex | -links | -perm | -size | -used | -printf | -context)
            return 0
        ;;
        -regextype)
            COMPREPLY=($( compgen -W 'emacs posix-awk posix-basic \
                posix-egrep posix-extended' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    for i in ${COMP_WORDS[@]};
    do
        [[ "$i" = [-\(\),\!]* ]] && exprfound=1 && break;
    done;
    if [[ "$exprfound" != 1 && "$cur" != [-\(\),\!]* ]]; then
        _filedir -d;
        return 0;
    fi;
    COMPREPLY=($( compgen -W '-daystart -depth -follow -help \
        -ignore_readdir_race -maxdepth -mindepth -mindepth -mount \
        -noignore_readdir_race -noleaf -regextype -version -warn -nowarn \
        -xdev \
        -amin -anewer -atime -cmin -cnewer -ctime -empty -executable -false \
        -fstype -gid -group -ilname -iname -inum -ipath -iregex -iwholename \
        -links -lname -mmin -mtime -name -newer -nogroup -nouser -path -perm \
        -readable -regex -samefile -size -true -type -uid -used -user \
        -wholename -writable -xtype -context \
        -delete -exec -execdir -fls -fprint -fprint0 -fprintf -ls -ok -okdir \
        -print -print0 -printf -prune -quit' -- "$cur" ));
    onlyonce=' -daystart -depth -follow -help -ignore_readdir_race -maxdepth \
       -mindepth -mount -noignore_readdir_race -noleaf -nowarn -regextype \
       -version -warn -xdev ';
    COMPREPLY=($(            (while read -d ' ' i; do
            [[ -z "$i" || "${onlyonce/ ${i%% *} / }" == "$onlyonce" ]] &&
            continue
            # flatten array with spaces on either side,
            # otherwise we cannot grep on word boundaries of
            # first and last word
            COMPREPLY=" ${COMPREPLY[@]} "
            # remove word from list of completions
            COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
            done
            printf '%s ' "${COMPREPLY[@]}") <<<"${COMP_WORDS[@]}"
          ));
    _filedir;
    return 0
}
_fstypes () 
{ 
    local fss;
    if [ -e /proc/filesystems ]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [ -d /etc/fs ] && command ls /etc/fs )";
    fi;
    [ -n "$fss" ] && COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$fss" -- "$cur" ))
}
_function () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ $1 == @(declare|typeset) ]]; then
        if [ "$prev" = -f ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W '-a -f -F -i -r -x -p' -- "$cur" ));
            fi;
        fi;
    else
        if [ $COMP_CWORD -eq 1 ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            COMPREPLY=("() $( type -- ${COMP_WORDS[1]} | sed -e 1,2d )");
        fi;
    fi
}
_gcc () 
{ 
    local cur cc backend;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    case $1 in 
        gcj)
            backend=jc1
        ;;
        gpc)
            backend=gpc1
        ;;
        *77)
            backend=f771
        ;;
        *)
            backend=cc1
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        cc=$( $1 -print-prog-name=$backend );
        COMPREPLY=($( compgen -W "$( $cc --help 2>/dev/null |            tr '\t' ' ' |            sed -e '/^  *-/!d' -e 's/ *-\([^ ]*\).*/-\1/' |            sort -u )" -- "$cur" ));
    else
        _filedir;
    fi
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [ $COMP_CWORD -ge 1 ]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent >&/dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl >&/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_gzip () 
{ 
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in 
        -b | --blocksize | -p | --processes | -S | --suffix | -h | --help | -V | --version)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$helpopts -1 -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.@(gz|t[ag]z)";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --force ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dlt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*f* ]] && xspec=;
        else
            if [[ "$prev" == '>' || "$prev" == '>>' ]]; then
                xspec=;
            else
                if [ "$prev" = '<' ]; then
                    xspec=;
                fi;
            fi;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_heimdal_encodings () 
{ 
    COMPREPLY=($( compgen -W 'des-cbc-mcrc des-cbc-md4 des-cbc-md5 \
        des3-cbc-sha1 arcfour-hmac-md5 aes128-cts-hmac-sha1-96 \
        aes256-cts-hmac-sha1-96' -- "$cur" ))
}
_heimdal_principals () 
{ 
    COMPREPLY=($( compgen -W "$( kadmin -l dump 2>/dev/null |         awk '{print $1}' )" -- "$cur" ))
}
_heimdal_realms () 
{ 
    COMPREPLY=($( compgen -W "( kadmin -l dump 2>/dev/null |         awk '{print $1}' | awk -F@ '{print $2}' )" -- "$cur" ))
}
_iconv () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -'?' | --help | --usage | -V | --version | --unicode-subst | --byte-subst | --widechar-subst)
            return 0
        ;;
        -f | --from-code | -t | --to-code)
            COMPREPLY=($( compgen -W '$( iconv -l | \
                sed -e "s@/*\$@@" -e "s/[,()]//g" )' -- "$cur" ));
            return 0
        ;;
        -o | --output)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" = -* ]]; then
        COMPREPLY=($( compgen -W '--from-code --to-code --list -c
            --unicode-subst --byte-subst --widechar-subst --output --silent
            --verbose --help --usage --version' -- "$cur" ));
        return 0;
    fi
}
_id () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -g --group -G --groups -n --name\
            -r --real -u --user --help --version' -- "$cur" ));
    else
        COMPREPLY=($( compgen -u "$cur" ));
    fi
}
_info () 
{ 
    local cur i infopath;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir;
        return 0;
    fi;
    infopath='/usr/share/info';
    if [ "${INFOPATH: -1:1}" == ':' ]; then
        infopath=${INFOPATH}${infopath};
    else
        if [ ${INFOPATH:+set} ]; then
            infopath=$INFOPATH;
        fi;
    fi;
    infopath=$infopath:;
    if [ -n "$cur" ]; then
        infopath="${infopath//://$cur* }";
    else
        infopath="${infopath//:// }";
    fi;
    COMPREPLY=($( eval command ls "$infopath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    for ((i=0 ; i < ${#COMPREPLY[@]} ; ++i ))
    do
        if [ "${COMPREPLY[$i]}" == 'dir' ]; then
            unset COMPREPLY[$i];
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.@(gz|bz2|xz|lzma)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_jar () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in 
        *c*f)
            _filedir
        ;;
        *f)
            _filedir '@([ejw]ar|zip|apk)'
        ;;
        *)
            _filedir
        ;;
    esac
}
_jarsigner () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -keystore)
            COMPREPLY=($( compgen -W 'NONE' -- "$cur" ));
            _filedir '@(jks|ks|p12|pfx)';
            return 0
        ;;
        -storepass | -keypass | -sigfile | -digestalg | -sigalg | -tsacert | -altsigner | -altsignerpath | -providerName | -providerClass | -providerArg)
            return 0
        ;;
        -storetype)
            COMPREPLY=($( compgen -W 'JKS PKCS11 PKCS12' -- "$cur" ));
            return 0
        ;;
        -signedjar)
            _filedir jar;
            return 0
        ;;
        -tsa)
            _filedir;
            return 0
        ;;
    esac;
    local i jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == *.jar && "${COMP_WORDS[i-1]}" != -signedjar ]]; then
            jar=true;
            break;
        fi;
    done;
    if ! $jar; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-keystore -storepass -storetype \
                -keypass -sigfile -signedjar -digestalg -sigalg -verify \
                -verbose -certs -tsa -tsacert -altsigner -altsignerpath \
                -protected -providerName -providerClass -providerArg'                 -- "$cur" ));
        fi;
        _filedir jar;
    fi
}
_java () 
{ 
    local cur prev words cword i;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev words cword;
    for ((i=1; i < $cword; i++))
    do
        case ${words[$i]} in 
            -cp | -classpath)
                ((i++))
            ;;
            -*)

            ;;
            *)
                _filedir;
                return 0
            ;;
        esac;
    done;
    case $cur in 
        -verbose:*)
            COMPREPLY=($( compgen -W 'class gc jni' -- "${cur#*:}" ));
            return 0
        ;;
        -javaagent:*)
            cur=${cur#*:};
            _filedir '@(jar|zip)';
            return 0
        ;;
        -agentpath:*)
            cur=${cur#*:};
            _filedir so;
            return 0
        ;;
        -splash:*)
            cur=${cur#*:};
            _filedir '@(gif|jp?(e)g|png)';
            return 0
        ;;
        -Xbootclasspath*:*)
            _java_path;
            return 0
        ;;
        -Xcheck:*)
            COMPREPLY=($( compgen -W 'jni' -- "${cur#*:}" ));
            return 0
        ;;
        -Xgc:*)
            COMPREPLY=($( compgen -W 'singlecon gencon singlepar genpar'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xgcprio:*)
            COMPREPLY=($( compgen -W 'throughput pausetime deterministic'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xloggc:* | -Xverboselog:*)
            cur=${cur#*:};
            _filedir;
            return 0
        ;;
        -Xshare:*)
            COMPREPLY=($( compgen -W 'auto off on' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverbose:*)
            COMPREPLY=($( compgen -W 'memory load jni cpuinfo codegen opt
                gcpause gcreport' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverify:*)
            COMPREPLY=($( compgen -W 'all none remote' -- "${cur#*:}" ));
            return 0
        ;;
        -D* | -*:*)
            return 0
        ;;
    esac;
    case $prev in 
        -cp | -classpath)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-client -server -agentlib: -agentpath:
            -classpath -D -d32 -d64 -enableassertions -disableassertions
            -enablesystemassertions -disablesystemassertions -jar -javaagent:
            -verbose -verbose -version -showversion -help -X' -- "$cur" ));
    else
        if [[ "$prev" == -jar ]]; then
            _filedir jar;
        else
            _java_classes;
        fi;
    fi;
    [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == -*[:=] ]] && type compopt >&/dev/null && compopt -o nospace;
    __ltrim_colon_completions "$cur"
}
_java_classes () 
{ 
    local classpath i;
    _java_find_classpath;
    cur=${cur//.//};
    for i in ${classpath//:/ };
    do
        if [[ "$i" == *.@(jar|zip) && -r $i ]]; then
            if type zipinfo >&/dev/null; then
                COMPREPLY=("${COMPREPLY[@]}" $( zipinfo -1                     "$i" "$cur*" 2>/dev/null |                     command grep '^[^$]*\.class$' ));
            else
                COMPREPLY=("${COMPREPLY[@]}" $( jar tf "$i"                     "$cur" | command grep '^[^$]*\.class$' ));
            fi;
        else
            if [ -d $i ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( command ls $i/$cur*.class 2>/dev/null |                     sed -ne '/\$/d' -e "s|^$i//*||p" ));
            fi;
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.class});
    COMPREPLY=(${COMPREPLY[@]//\//.})
}
_java_find_classpath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -@(cp|classpath) ]]; then
            classpath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    [ -z "$classpath" ] && classpath=$CLASSPATH;
    [ -z "$classpath" ] && classpath=.
}
_java_find_sourcepath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -sourcepath ]]; then
            sourcepath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$sourcepath" ]; then
        _java_find_classpath;
        sourcepath=$classpath;
    fi
}
_java_packages () 
{ 
    local sourcepath i;
    _java_find_sourcepath;
    cur=${cur//.//};
    for i in ${sourcepath//:/ };
    do
        if [ -d $i ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( command ls -F -d                 $i/$cur* 2>/dev/null | sed -e 's|^'$i'/||' ));
        fi;
    done;
    COMPREPLY=($( tr " " "\n" <<<"${COMPREPLY[@]}" | command grep "/$" ));
    COMPREPLY=(${COMPREPLY[@]%/});
    cur=${COMPREPLY[@]//\//.}
}
_java_path () 
{ 
    cur=${cur##*:};
    _filedir '@(jar|zip)'
}
_javac () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -d)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g -g:none -g:lines -g:vars \
            -g:source -O -nowarn -verbose -deprecation -classpath \
            -sourcepath -bootclasspath -extdirs -d -encoding -source \
            -target -help' -- "$cur" ));
    else
        _filedir java;
    fi
}
_javadoc () 
{ 
    COMPREPLY=();
    local cur prev classpath;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -overview | -helpfile)
            _filedir '?(x)htm?(l)';
            return 0
        ;;
        -stylesheetfile)
            _filedir css;
            return 0
        ;;
        -d | -link | -linkoffline)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -docletpath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-overview -public -protected \
            -package -private -help -doclet -docletpath \
            -sourcepath -classpath -exclude -subpackages \
            -breakiterator -bootclasspath -source -extdirs \
            -verbose -locale -encoding -J -d -use -version \
            -author -docfilessubdirs -splitindex \
            -windowtitle -doctitle -header -footer -bottom \
            -link -linkoffline -excludedocfilessubdir \
            -group -nocomment -nodeprecated -noqualifier \
            -nosince -nodeprecatedlist -notree -noindex \
            -nohelp -nonavbar -quiet -serialwarn -tag \
            -taglet -tagletpath -charset -helpfile \
            -linksource -stylesheetfile -docencoding' -- "$cur" ));
    else
        _filedir java;
        _java_packages;
    fi
}
_javaws () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -help | -license | -about | -viewer | -arg | -param | -property | -update | -umask)
            return 0
        ;;
        -basedir | -codebase)
            _filedir -d;
            return 0
        ;;
        -uninstall | -import)
            _filedir jnlp;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W "$( _parse_help "$1" -help ) " -- "$cur" ));
        return 0;
    fi;
    _filedir jnlp
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kill () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pids;
    fi
}
_killall () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pnames;
    fi;
    return 0
}
_known_hosts () 
{ 
    local options;
    COMPREPLY=();
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options="$options -c";
    _known_hosts_real $options "$(_get_cword :)"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [ $# -lt $OPTIND ] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [ $# -ge $OPTIND ] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [ $# -ge $OPTIND ]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [ -n "$configfile" ]; then
        [ -r "$configfile" ] && config=("${config[@]}" "$configfile");
    else
        for i in /etc/ssh/ssh_config "${HOME}/.ssh/config" "${HOME}/.ssh2/config";
        do
            [ -r $i ] && config=("${config[@]}" "$i");
        done;
    fi;
    if [ ${#config[@]} -gt 0 ]; then
        local OIFS=$IFS IFS='
';
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        for i in "${tmpkh[@]}";
        do
            i=${i//\"};
            __expand_tilde_by_ref i;
            [ -r "$i" ] && kh=("${kh[@]}" "$i");
        done;
        IFS=$OIFS;
    fi;
    if [ -z "$configfile" ]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [ -r $i ] && kh=("${kh[@]}" $i);
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [ -d $i ] && khd=("${khd[@]}" $i/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [ -z "$awkcur" ]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [ ${#kh[@]} -gt 0 ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {for (i=1; i<=2; ++i) { \
            sub(" .*$", "", $i); \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [ ${#khd[@]} -gt 0 ]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY=("${COMPREPLY[@]}" $host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}[[:blank:]]\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY=("${COMPREPLY[@]}" $( compgen  -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && type avahi-browse >&/dev/null; then
        COMPREPLY=("${COMPREPLY[@]}" $(             compgen -P "$prefix$user" -S "$suffix" -W             "$( avahi-browse -cpr _workstation._tcp 2>/dev/null |                  awk -F';' '/^=/ { print $7 }' | sort -u )" -- "$cur" ));
    fi;
    if [ -n "${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1}" ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_ktutil () 
{ 
    local cur prev command options split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -p | --principal)
            _heimdal_principals;
            return 0
        ;;
        -e | --enctype)
            _heimdal_encodings;
            return 0
        ;;
        -a | --admin-server)
            _known_hosts_real "$cur";
            return 0
        ;;
        -r | --realm)
            _heimdal_realms;
            return 0
        ;;
        -s | -k | --srvtab | --keytab)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    commands='add change copy get list remove rename purge srvconvert \
        srv2keytab srvcreate key2srvtab';
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            -k | --keytab)
                i=$(($i+1))
            ;;
            -*)

            ;;
            *)
                command=${COMP_WORDS[i]};
                break
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        case $command in 
            add)
                options='-p --principal -V -e --enctype -w --password -r \
                    --random -s --no-salt -h --hex'
            ;;
            change)
                options='-r --realm -a --admin-server -s --server-port'
            ;;
            get)
                options='-p --principal -e --enctype -r --realm -a \
                    --admin-server -s server --server-port'
            ;;
            list)
                options='--keys --timestamp'
            ;;
            remove)
                options='-p --principal -V --kvno -e --enctype'
            ;;
            purge)
                options='--age'
            ;;
            srv2keytab | key2srvtab)
                options='-s --srvtab'
            ;;
            *)
                options='-k --keytab -v --verbose --version -v --help'
            ;;
        esac;
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    else
        case $command in 
            copy)
                _filedir
            ;;
            get)
                _heimdal_principals
            ;;
            rename)
                _heimdal_principals
            ;;
            *)
                COMPREPLY=($( compgen -W "$commands" -- "$cur" ))
            ;;
        esac;
    fi
}
_ldap_protocols () 
{ 
    COMPREPLY=($( compgen -W '2 3' -- "$cur" ))
}
_ldap_uris () 
{ 
    COMPREPLY=($( compgen -W 'ldap:// ldaps://' -- "$cur" ))
}
_ldapaddmodify () 
{ 
    local cur prev options;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -S | -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        options='-c -S -n -v -M -MM -d -D -W -w -y -h -H -p -P -O -I \
            -Q -U -R -x -X -Y -Z -ZZ -f';
        if [[ ${COMP_WORDS[0]} == ldapmodify ]]; then
            options="$options -a";
        fi;
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    fi
}
_ldapcompare () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -z -M -MM -d -D -W -w -y \
            -H -h -P -p -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapdelete () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -c -M -MM -d -f -D -W -w -y \
            -H -h -P -p -O -U -R -r -x -I -Q -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapmodrdn () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -s -n -v -c -M -MM -d -D -W -w \
            -y -H -h -P -p -O -I -Q -U -R -x -X -Y -Z -ZZ -f' -- "$cur" ));
    fi
}
_ldappasswd () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -t | -T | -y)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-A -a -t -d -D -H -h -n -p -S -s -T \
            -v -W -w -y -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapsearch () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -T)
            _filedir -d;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -s)
            COMPREPLY=($( compgen -W 'base one sub children' -- "$cur" ));
            return 0
        ;;
        -a)
            COMPREPLY=($( compgen -W 'never always search find'                 -- "$cur" ));
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -u -v -t -tt -T -F -A -C -L -LL \
            -LLL -M -MM -S -d -f -x -D -W -w -y -H -h -p -b -s -a \
            -P -e -E -l -z -O -I -Q -U -R -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapwhoami () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -z -d -D -W -w -y -H -h -p -P \
            -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_linux_fstab () 
{ 
    COMPREPLY=();
    local fs_spec fs_file fs_other;
    local oldifs="$IFS";
    while read -r fs_spec fs_file fs_other; do
        if [[ $fs_spec = [#]* ]]; then
            continue;
        fi;
        if [[ $1 == -L ]]; then
            local fs_label=${fs_spec/#LABEL=};
            if [[ $fs_label != "$fs_spec" ]]; then
                __linux_fstab_unescape fs_label;
                IFS='';
                COMPREPLY+=("$fs_label");
                IFS=$oldifs;
            fi;
        else
            __linux_fstab_unescape fs_spec;
            __linux_fstab_unescape fs_file;
            IFS='';
            [[ $fs_spec = */* ]] && COMPREPLY+=("$fs_spec");
            [[ $fs_file = */* ]] && COMPREPLY+=("$fs_file");
            IFS=$oldifs;
        fi;
    done;
    _reply_compgen_array
}
_longopt () 
{ 
    local cur prev split=false;
    _get_comp_words_by_ref -n = cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --*[Dd][Ii][Rr]*)
            _filedir -d;
            return 0
        ;;
        --*[Ff][Ii][Ll][Ee]* | --*[Pp][Aa][Tt][Hh]*)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}\).*/\1/p' | sort -u )"             -- "$cur" ));
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_look () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W '$(look "$cur" 2>/dev/null)' -- "$cur" ));
    fi
}
_lsof () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -'?' | -h | +c | -c | -d | -F | -i | +r | -r | -s | -S | -T)
            return 0
        ;;
        -A | -k | -m | +m | -o)
            _filedir;
            return 0
        ;;
        +d | +D)
            _filedir -d;
            return 0
        ;;
        -D)
            COMPREPLY=($( compgen -W '? b i r u' -- "$cur" ));
            return 0
        ;;
        -f)
            COMPREPLY=($( compgen -W 'c f g G n' -- "$cur" ));
            return 0
        ;;
        -g)
            _pgids;
            return 0
        ;;
        -p)
            _pids;
            return 0
        ;;
        -u)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == [-+]* ]]; then
        COMPREPLY=($( compgen -W '-h -a -A -b -c +c -C +d -d +D -D +f -f -F -g
            -i -k -l +L -L +m -m +M -M -n -N -o -O -p -P +r -r -R -s -S -T -t
            -u -U -v -V +w -w -x -X -z -Z' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_lzma () 
{ 
    local cur prev xspec;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-1 -2 -3 -4 -5 -6 -7 -8 -9 \
            --help --decompress --compress --keep --force --suffix \
            --test --stdout --quiet --verbose --license --list \
            --version --small --fast --best --text' -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.@(lzma|tlz)";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY=("${COMPREPLY[@]}" $( ifconfig -a 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( arp -an 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_make () 
{ 
    local file makef makef_dir="." makef_inc cur prev i split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -f | -o | -W | --file | --makefile | --old-file | --new-file | --assume-old | --assume-new | --what-if)
            _filedir;
            return 0
        ;;
        -I | -C | --directory | --include-dir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -m -B -C -d -e -f -h -i -I\
            -j -l -k -n -o -p -q -r -R - s -S -t -v -w -W \
            --always-make --directory --debug \
            --environment-overrides --file --makefile --help \
            --ignore-errors --include-dir --jobs --load-average \
            --max-load --keep-going --just-print --dry-run \
            --recon --old-file --assume-old --print-data-base \
            --question --no-builtin-rules --no-builtin-variables \
            --silent --quiet --no-keep-goind --stop --touch \
            --version --print-directory --no-print-directory \
            --what-if --new-file --assume-new \
            --warn-undefined-variables' -- "$cur" ));
    else
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(C|-directory) ]]; then
                eval makef_dir=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(f|-?(make)file) ]]; then
                eval makef=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        [ -n "$makef" ] && makef="-f ${makef}";
        [ -n "$makef_dir" ] && makef_dir="-C ${makef_dir}";
        COMPREPLY=($( compgen -W "$( make -qp $makef $makef_dir 2>/dev/null |             awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
            {split($1,A,/ /);for(i in A)print A[i]}' )"             -- "$cur" ));
    fi
}
_man () 
{ 
    local cur i prev sect manpath manext mansect uname;
    manext="@([0-9lnp]|[0-9][px]|man|3pm)?(.@([gx]z|bz2|lzma|Z))";
    mansect="@([0-9lnp]|[0-9][px]|3pm)";
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    if [[ "$prev" == -l ]]; then
        _filedir $manext;
        return 0;
    fi;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir $manext;
        return 0;
    fi;
    uname=$( uname -s );
    if [[ $uname == @(Darwin|Linux|GNU|GNU/*|FreeBSD|Cygwin|CYGWIN_*) ]]; then
        manpath=$( manpath 2>/dev/null || command man --path );
    else
        manpath=$MANPATH;
    fi;
    if [ -z "$manpath" ]; then
        COMPREPLY=($( compgen -c -- "$cur" ));
        return 0;
    fi;
    [[ "$prev" == $mansect ]] && sect=$prev || sect='*';
    manpath=$manpath:;
    if [ -n "$cur" ]; then
        manpath="${manpath//://*man$sect/$cur* } ${manpath//://*cat$sect/$cur* }";
    else
        manpath="${manpath//://*man$sect/ } ${manpath//://*cat$sect/ }";
    fi;
    COMPREPLY=($( eval command ls "$manpath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    COMPREPLY=(${COMPREPLY[@]%.@([gx]z|bz2|lzma|Z)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    if [[ "$prev" != $mansect ]]; then
        local start=${#COMPREPLY[@]};
        _filedir $manext;
        for ((i=$start; i < ${#COMPREPLY[@]}; i++ ))
        do
            [[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]};
        done;
    fi;
    __ltrim_colon_completions "$cur";
    return 0
}
_mktemp () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --version | --suffix)
            return 0
        ;;
        --tmpdir | -p)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    [[ "$cur" == -* ]] && COMPREPLY=($( compgen -W '-d -u -q -p -t' -- "$cur" ))
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -R $modpath |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.gz\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mount () 
{ 
    local cur sm host prev;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    case $prev in 
        -t | --types)
            _fstypes;
            return 0
        ;;
    esac;
    [[ "$cur" == \\ ]] && cur="/";
    if [[ "$cur" == *:* ]]; then
        for sm in "$(type -P showmount)" {,/usr}/{,s}bin/showmount;
        do
            [ -x "$sm" ] || continue;
            COMPREPLY=($( compgen -W "$( "$sm" -e ${cur%%:*} |                 awk 'NR>1 {print $1}' )" -- "${cur#*:}" ));
            return 0;
        done;
    fi;
    if [[ "$cur" == //* ]]; then
        host=${cur#//};
        host=${host%%/*};
        if [ -n "$host" ]; then
            COMPREPLY=($( compgen -P "//$host" -W                 "$( smbclient -d 0 -NL $host 2>/dev/null |
                sed -ne '/^['"$'\t '"']*Sharename/,/^$/p' |
                sed -ne '3,$s|^[^A-Za-z]*\([^'"$'\t '"']*\).*$|/\1|p' )"                     -- "${cur#//$host}" ));
        fi;
    else
        if [ -r /etc/vfstab ]; then
            COMPREPLY=($( compgen -W "$( awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' /etc/vfstab )" -- "$cur" ));
        else
            if [ ! -e /etc/fstab ]; then
                COMPREPLY=($( compgen -W "$( mount | awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' )" -- "$cur" ));
            else
                if [ "$prev" = -L ]; then
                    _linux_fstab -L < /etc/fstab;
                else
                    if [ "$prev" = -U ]; then
                        COMPREPLY=($( compgen -W '$(sed -ne "s/^[[:space:]]*UUID=\([^[:space:]]*\).*/\1/p" /etc/fstab )' -- "$cur" ));
                    else
                        _linux_fstab < /etc/fstab;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}
_mysqladmin () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -h | --host)
            _known_hosts_real "$cur";
            return 0
        ;;
        --character-sets-dir | --ssl-capath)
            _filedir -d;
            return 0
        ;;
        -S | --socket)
            _filedir sock;
            return 0
        ;;
        --defaults-file | --defaults-extra-file)
            _filedir;
            return 0
        ;;
        -c | --count | --default-character-set | -P | --port | -O | --set-variable | -i | --sleep | --ssl-ca | --ssl-cert | --ssl-cipher | --ssl-key | -w | --wait | --connect_timeout | --shutdown_timeout)
            return 0
        ;;
        '-?' | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    COMPREPLY=($( compgen -W '--count --debug-check --debug-info --force \
        --compress --character-sets-dir --default-character-set --help --host \
        --no-beep --password --port --protocol --relative --set-variable \
        --silent --socket --sleep --ssl --ssl-ca --ssl-capath --ssl-cert \
        --ssl-cipher --ssl-key --ssl-verify-server-cert --user --verbose \
        --version --vertical --wait --connect_timeout --shutdown_timeout \
        --print-defaults --no-defaults --defaults-file --defaults-extra-file'         -- "$cur" ));
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'create debug drop extended-status flush-hosts \
        flush-logs flush-status flush-tables flush-threads flush-privileges \
        kill password old-password ping processlist reload refresh shutdown \
        status start-slave stop-slave variables version' -- "$cur" ))
}
_newgrp () 
{ 
    COMPREPLY=();
    if [[ "`_get_cword`" == "-" ]]; then
        COMPREPLY=(-);
    else
        _allowed_groups;
    fi
}
_npm_completion () 
{ 
    local words cword;
    if type _get_comp_words_by_ref >&/dev/null; then
        _get_comp_words_by_ref -n = -n @ -n : -w words -i cword;
    else
        cword="$COMP_CWORD";
        words=("${COMP_WORDS[@]}");
    fi;
    local si="$IFS";
    IFS='
' COMPREPLY=($(COMP_CWORD="$cword"                            COMP_LINE="$COMP_LINE"                            COMP_POINT="$COMP_POINT"                            npm completion -- "${words[@]}"                            2>/dev/null)) || return $?;
    IFS="$si";
    if type __ltrim_colon_completions >&/dev/null; then
        __ltrim_colon_completions "${words[cword]}";
    fi
}
_nslookup () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -P '-' -W 'all class= debug d2 domain= srchlist= \
        defname search port= querytype= type= recurse retry root timeout vc \
        ignoretc' -- "$cur" ))
}
_openssl () 
{ 
    local cur prev commands command options formats;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    commands='asn1parse ca ciphers crl crl2pkcs7 dgst dh dhparam dsa \
        dsaparam ec ecparam enc engine errstr gendh gendsa genrsa \
        nseq ocsp passwd pkcs12 pkcs7 pkcs8 prime rand req rsa \
        rsautl s_client s_server s_time sess_id smime speed spkac \
        verify version x509 md2 md4 md5 rmd160 sha sha1 aes-128-cbc \
        aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb \
        base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc \
        camellia-128-ecb camellia-192-cbc camellia-192-ecb \
        camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc \
        cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb \
        des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 \
        des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx rc2 \
        rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 \
        rc4-40';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$commands" -- "$cur" ));
    else
        command=${COMP_WORDS[1]};
        case $prev in 
            -CA | -CAfile | -CAkey | -CAserial | -cert | -certfile | -config | -content | -dcert | -dkey | -dhparam | -extfile | -in | -inkey | -kfile | -key | -keyout | -out | -oid | -prvrify | -rand | -recip | -revoke | -sess_in | -sess_out | -spkac | -sign | -signkey | -signer | -signature | -ss_cert | -untrusted | -verify)
                _filedir;
                return 0
            ;;
            -outdir | -CApath)
                _filedir -d;
                return 0
            ;;
            -name | -crlexts | -extensions)
                _openssl_sections;
                return 0
            ;;
            -inform | -outform | -keyform | -certform | -CAform | -CAkeyform | -dkeyform | -dcertform)
                formats='DER PEM';
                case $command in 
                    x509)
                        formats="$formats NET"
                    ;;
                    smime)
                        formats="$formats SMIME"
                    ;;
                esac;
                COMPREPLY=($( compgen -W "$formats" -- "$cur" ));
                return 0
            ;;
            -connect)
                _known_hosts_real "$cur";
                return 0
            ;;
            -starttls)
                COMPREPLY=($( compgen -W 'smtp pop3 imap ftp'                     -- "$cur" ));
                return 0
            ;;
            -cipher)
                COMPREPLY=($( compgen -W "$(openssl ciphers |                     tr ':' '\n')" -- "$cur" ));
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                asn1parse)
                    options='-inform -in -out -noout -offset -length -i -oid \
                        -strparse'
                ;;
                ca)
                    options='-verbose -config -name -gencrl -revoke \
                        -crl_reason -crl_hold -crl_compromise \
                        -crl_CA_compromise -crldays -crlhours -crlexts \
                        -startdate -enddate -days -md -policy -keyfile -key \
                        -passin -cert -selfsig -in -out -notext -outdir \
                        -infiles -spkac -ss_cert -preserveDN -noemailDN \
                        -batch -msie_hack -extensions -extfile -engine \
                        -subj -utf8 -multivalue-rdn'
                ;;
                ciphers)
                    options='-v -ssl2 -ssl3 -tls1'
                ;;
                crl)
                    options='-inform -outform -text -in -out -noout -hash \
                        -issuer -lastupdate -nextupdate -CAfile -CApath'
                ;;
                crl2pkcs7)
                    options='-inform -outform -in -out -print_certs'
                ;;
                dgst)
                    options='-md5 -md4 -md2 -sha1 -sha -mdc2 -ripemd160 -dss1 \
                        -c -d -hex -binary -out -sign -verify -prverify \
                        -signature'
                ;;
                dsa)
                    options='-inform -outform -in -passin -out -passout -des \
                        -des3 -idea -text -noout -modulus -pubin -pubout'
                ;;
                dsaparam)
                    options='-inform -outform -in -out -noout -text -C -rand \
                        -genkey'
                ;;
                enc)
                    options='-ciphername -in -out -pass -e -d -a -A -k -kfile \
                        -S -K -iv -p -P -bufsize -debug'
                ;;
                dhparam)
                    options='-inform -outform -in -out -dsaparam -noout -text \
                        -C -2 -5 -rand'
                ;;
                gendsa)
                    options='-out -des -des3 -idea -rand'
                ;;
                genrsa)
                    options='-out -passout -des -des3 -idea -f4 -3 -rand'
                ;;
                pkcs7)
                    options='-inform -outform -in -out -print_certs -text \
                        -noout'
                ;;
                rand)
                    options='-out -rand -base64'
                ;;
                req)
                    options='-inform -outform -in -passin -out -passout -text \
                        -noout -verify -modulus -new -rand -newkey -newkey \
                        -nodes -key -keyform -keyout -md5 -sha1 -md2 -mdc2 \
                        -config -x509 -days -asn1-kludge -newhdr -extensions \
                        -reqexts section'
                ;;
                rsa)
                    options='-inform -outform -in -passin -out -passout \
                        -sgckey -des -des3 -idea -text -noout -modulus -check \
                        -pubin -pubout -engine'
                ;;
                rsautl)
                    options='-in -out -inkey -pubin -certin -sign -verify \
                        -encrypt -decrypt -pkcs -ssl -raw -hexdump -asn1parse'
                ;;
                s_client)
                    options='-connect -verify -cert -certform -key -keyform \
                        -pass -CApath -CAfile -reconnect -pause -showcerts \
                        -debug -msg -nbio_test -state -nbio -crlf -ign_eof \
                        -quiet -ssl2 -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 \
                        -bugs -cipher -starttls -engine -tlsextdebug \
                        -no_ticket -sess_out -sess_in -rand'
                ;;
                s_server)
                    options='-accept -context -verify -Verify -crl_check \
                        -crl_check_all -cert -certform -key -keyform -pass \
                        -dcert -dcertform -dkey -dkeyform -dpass -dhparam \
                        -nbio -nbio_test -crlf -debug -msg -state -CApath \
                        -CAfile -nocert -cipher -quiet -no_tmp_rsa -ssl2 \
                        -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 -no_dhe \
                        -bugs -hack -www -WWW -HTTP -engine -tlsextdebug \
                        -no_ticket -id_prefix -rand'
                ;;
                s_time)
                    options='-connect -www -cert -key -CApath -CAfile -reuse \
                        -new -verify -nbio -time -ssl2 -ssl3 -bugs -cipher'
                ;;
                sess_id)
                    options='-inform -outform -in -out -text -noout -context \
                        ID'
                ;;
                smime)
                    options='-encrypt -decrypt -sign -verify -pk7out -des \
                        -des3 -rc2-40 -rc2-64 -rc2-128 -aes128 -aes192 -aes256 \
                        -in -certfile -signer -recip -inform -passin -inkey \
                        -out -outform -content -to -from -subject -text -rand'
                ;;
                speed)
                    options='-engine'
                ;;
                verify)
                    options='-CApath -CAfile -purpose -untrusted -help \
                        -issuer_checks -verbose -certificates'
                ;;
                x509)
                    options='-inform -outform -keyform -CAform -CAkeyform -in \
                        -out -serial -hash -subject_hash -issuer_hash -subject \
                        -issuer -nameopt -email -startdate -enddate -purpose \
                        -dates -modulus -fingerprint -alias -noout -trustout \
                        -clrtrust -clrreject -addtrust -addreject -setalias \
                        -days -set_serial -signkey -x509toreq -req -CA -CAkey \
                        -CAcreateserial -CAserial -text -C -md2 -md5 -sha1 \
                        -mdc2 -clrext -extfile -extensions -engine'
                ;;
                md5 | md4 | md2 | sha1 | sha | mdc2 | ripemd160)
                    options='-c -d'
                ;;
            esac;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ));
        else
            if [[ "$command" == speed ]]; then
                COMPREPLY=($( compgen -W 'md2 mdc2 md5 hmac sha1 rmd160 \
                    idea-cbc rc2-cbc rc5-cbc bf-cbc des-cbc des-ede3 rc4 \
                    rsa512 rsa1024 rsa2048 rsa4096 dsa512 dsa1024 dsa2048 idea \
                    rc2 des rsa blowfish' -- "$cur" ));
            else
                _filedir;
            fi;
        fi;
    fi
}
_openssl_sections () 
{ 
    local config f;
    for ((i=2; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -config ]]; then
            config=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$config" ]; then
        for f in /etc/ssl/openssl.cnf /etc/pki/tls/openssl.cnf /usr/share/ssl/openssl.cnf;
        do
            [ -f $f ] && config=$f && break;
        done;
    fi;
    [ ! -f "$config" ] && return 0;
    COMPREPLY=($( compgen -W "$( awk '/\[.*\]/ {print $2}' $config )"         -- "$cur" ))
}
_pack200 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -S | --segment-limit | -P | --pass-file | -C | --class-attribute | -F | --field-attribute | -M | --method-attribute | -D | --code-attribute | '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -E | --effort)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -m | --modification-time)
            COMPREPLY=($( compgen -W 'latest keep' -- "$cur" ));
            return 0
        ;;
        -U | --unknown-attribute)
            COMPREPLY=($( compgen -W 'error strip pass' -- "$cur" ));
            return 0
        ;;
        -f | --config-file)
            _filedir properties;
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
        -r | --repack)
            _filedir jar;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--no-gzip --gzip --strip-debug \
                --no-keep-file-order --segment-limit= --effort= \
                --deflate-hint= --modification-time= --pass-file= \
                --unknown-attribute= --class-attribute= --field-attribute= \
                --method-attribute= --code-attribute= --config-file= \
                --verbose --quiet --log-file= --help --version -J \
                --repack' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt >&/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_parse_help () 
{ 
    $1 ${2:---help} 2>&1 | sed -e '/^[[:space:]]*-/!d' -e 's|[,/]| |g' | awk '{ print $1; if ($2 ~ /^-/) { print $2 } }' | sed -e 's|[<=].*||'
}
_passwd () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -n | -x | -w | -i | -\? | --help | --usage)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-k -l --stdin -u -d -n -x -w -i -S \
            -? --help --usage' -- "$cur" ));
        return 0;
    fi;
    _allowed_users
}
_pci_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_perl () 
{ 
    local cur prev prefix temp;
    local optPrefix optSuffix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        optPrefix=-P$prev;
        optSuffix=-S/;
        prefix=$prev;
    fi;
    case $prev in 
        -D | -e | -E | -i | -F | -l)
            return 0
        ;;
        -I | -x)
            local IFS='
';
            _compopt_o_filenames;
            COMPREPLY=($( compgen -d $optPrefix $optSuffix -- "$cur" ));
            return 0
        ;;
        -m | -M)
            temp="${cur#-}";
            prefix="$prefix${cur%$temp}";
            cur="$temp";
            _perlmodules $1;
            return 0
        ;;
        -V)
            if [[ $cur == :* ]]; then
                temp="${cur##+(:)}";
                prefix="$prefix${cur%$temp}";
                local IFS='
';
                COMPREPLY=($( compgen -P "$prefix" -W                     '$( $1 -MConfig -e "print join \"\\n\",
                        keys %Config::Config" 2>/dev/null )' -- "$temp" ));
                __ltrim_colon_completions "$prefix$temp";
            fi;
            return 0
        ;;
        -d | -dt)
            if [[ $cur == :* ]]; then
                temp="${cur#:}";
                prefix="$prefix${cur%$temp}";
                cur="Devel::$temp";
                _perlmodules $1;
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-C -s -T -u -U -W -X -h -v -V -c -w -d \
            -D -p -n -a -F -l -0 -I -m -M -P -S -x -i -e ' -- "$cur" ));
    else
        _filedir;
    fi
}
_perldoc () 
{ 
    local cur prev prefix temp;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        prefix=$prev;
    fi;
    case $prev in 
        -f)
            _perlfunctions "$cur";
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -v -t -u -m -l -F -X -f -q' -- "$cur" ));
    else
        if [[ "$cur" != */* ]]; then
            _perlmodules;
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 '$( PAGER=/bin/cat man perl |  \
                sed -ne "/perl.*Perl overview/,/perlwin32/p" | \
                awk "\$NF=2 { print \$1}" | command grep perl )' -- "$cur" ));
        fi;
        _filedir 'p@(l|m|od)';
    fi
}
_perlfunctions () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W "$( ${BASH_SOURCE[0]%/*}/helpers/perl functions $cur )" -- "$cur" ))
}
_perlmodules () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W "$( $1 ${BASH_SOURCE[0]%/*}/helpers/perl modules $cur )" -- "$cur" ));
    __ltrim_colon_completions "$prefix$cur"
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pgrep () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _pnames;
    return 0
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pkg_config () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        --variable | --define-variable | --atleast-version | --atleast-pkgconfig-version | --exact-version | --max-version)
            return 0
        ;;
        -\? | --help | --version | --usage)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--version --modversion \
            --atleast-pkgconfig-version --libs --static \
            --short-errors --libs-only-l --libs-only-other \
            --libs-only-L --cflags --cflags-only-I \
            --cflags-only-other --variable --define-variable \
            --exists --uninstalled --atleast-version \
            --exact-version --max-version --list-all --debug \
            --print-errors --silence-errors --errors-to-stdout \
            --print-provides --print-requires --help --usage' -- "$cur"));
    else
        COMPREPLY=($( compgen -W "$( pkg-config --list-all             2>/dev/null | awk '{print $1}' )" -- "$cur" ));
    fi
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_postcat () 
{ 
    local cur prev pval len idx qfile;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            _filedir -d;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -q -v' -- "$cur" ));
        return 0;
    fi;
    qfile=0;
    for idx in "${COMP_WORDS[@]}";
    do
        [[ "$idx" = -q ]] && qfile=1 && break;
    done;
    if [[ $qfile == 1 ]]; then
        len=${#cur};
        idx=0;
        for pval in $( mailq 2>/dev/null |             sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* !].*$//' );
        do
            if [[ "$cur" == "${pval:0:$len}" ]]; then
                COMPREPLY[$idx]=$pval;
                idx=$(($idx+1));
            fi;
        done;
        return 0;
    else
        _filedir;
        return 0;
    fi
}
_postconf () 
{ 
    local cur prev pval len idx eqext;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -b | -t)
            _filedir;
            return 0
        ;;
        -c)
            _filedir -d;
            return 0
        ;;
        -e)
            cur=${cur#[\"\']};
            eqext='='
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-A -a -b -c -d -e -h -m -l -n -t -v'             -- "$cur" ));
        return 0;
    fi;
    len=${#cur};
    idx=0;
    for pval in $( /usr/sbin/postconf 2>/dev/null | cut -d ' ' -f 1 );
    do
        if [[ "$cur" == "${pval:0:$len}" ]]; then
            COMPREPLY[$idx]="$pval$eqext";
            idx=$(($idx+1));
        fi;
    done;
    return 0
}
_postfix () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            _filedir -d;
            return 0
        ;;
        -D)
            COMPREPLY=($( compgen -W 'start' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -D -v' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -W 'check start stop abort flush reload status \
        set-permissions upgrade-configuration' -- "$cur" ))
}
_postmap () 
{ 
    local cur prev len idx;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            _filedir -d;
            return 0
        ;;
        -[dq])
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-N -f -i -n -o -p -r -v -w -c -d -q'             -- "$cur" ));
        return 0;
    fi;
    if [[ "$cur" == *:* ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -f -- "${cur#*:}" ));
    else
        len=${#cur};
        idx=0;
        for pval in $( /usr/sbin/postconf -m );
        do
            if [[ "$cur" == "${pval:0:$len}" ]]; then
                COMPREPLY[$idx]="$pval:";
                idx=$(($idx+1));
            fi;
        done;
        if [[ $idx -eq 0 ]]; then
            _compopt_o_filenames;
            COMPREPLY=($( compgen -f -- "$cur" ));
        fi;
    fi;
    return 0
}
_postsuper () 
{ 
    local cur prev pval len idx;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            _filedir -d;
            return 0
        ;;
        -[dr])
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* !].*$//' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
        -h)
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* ].*$//; /!$/d' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
        -H)
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; /^[0-9A-Z]*[* ]/d; s/!.*$//' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -d -h -H -p -r -s -v' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -W 'hold incoming active deferred' -- "$cur" ))
}
_python () 
{ 
    local prev cur i;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -'?' | -h | --help | -V | --version | -c | -m)
            return 0
        ;;
        -Q)
            COMPREPLY=($( compgen -W "old new warn warnall" -- "$cur" ));
            return 0
        ;;
        -W)
            COMPREPLY=($( compgen -W "ignore default all module once error"                 -- "$cur" ));
            return 0
        ;;
        !(?(*/)python*([0-9.])|-?))
            [[ $COMP_CWORD -lt 2 || ${COMP_WORDS[COMP_CWORD-2]} != -@(Q|W) ]] && _filedir
        ;;
    esac;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -c ]]; then
            _filedir;
        fi;
    done;
    if [[ "$cur" != -* ]]; then
        _filedir 'py?([co])';
    else
        COMPREPLY=($( compgen -W "$( _parse_help $1 -h )" -- "$cur" ));
    fi;
    return 0
}
_quota () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-F --format -g --group -u --user -v \
            --verbose -s --human-readable -p --raw-grace -i --no-autofs -l \
            --local-only -A --all-nfs -m --no-mixed-pathnames -q --quiet -Q \
            --quiet-refuse -w --no-wrap' -- "$cur" ));
    else
        _user_or_group;
    fi
}
_quota_formats () 
{ 
    COMPREPLY=($( compgen -W 'vfsold vfsv0 rpc xfs' -- "$cur" ))
}
_quotacheck () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b --backup -v --verbose -d --debug \
            -g --group -u --user -c --create-files -f --force -i \
            --interactive -n --use-first-dquot -M --try-remount -m \
            --no-remount -R --exclude-root -F --format -a --all' -- "$cur" ));
    else
        _filesystems;
    fi
}
_quotaoff () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
        -x | --xfs-command)
            COMPREPLY=($( compgen -W 'delete enforce' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -u --user \
            -g --group -p --print-state -x --xfs-command -F --format'             -- "$cur" ));
    else
        _filesystems;
    fi
}
_quotaon () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -u --user \
            -g --group -f --off -p --print-state -F --format' -- "$cur" ));
    else
        _filesystems;
    fi
}
_quote_readline_by_ref () 
{ 
    if [[ ${1:0:1} == "'" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            printf -v $2 %s "${1:1}";
        else
            printf -v $2 %q "${1:1}";
            printf -v $2 %q ${!2};
        fi;
    else
        if [[ ${BASH_VERSINFO[0]} -le 3 && ${1:0:1} == '"' ]]; then
            printf -v $2 %q "${1:1}";
        else
            printf -v $2 %q "$1";
        fi;
    fi;
    [[ ${!2:0:1} == '$' ]] && eval $2=${!2}
}
_rbenv () 
{ 
    COMPREPLY=();
    local word="${COMP_WORDS[COMP_CWORD]}";
    if [ "$COMP_CWORD" -eq 1 ]; then
        COMPREPLY=($(compgen -W "$(rbenv commands)" -- "$word"));
    else
        local words=("${COMP_WORDS[@]}");
        unset words[0];
        unset words[$COMP_CWORD];
        local completions=$(rbenv completions "${words[@]}");
        COMPREPLY=($(compgen -W "$completions" -- "$word"));
    fi
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p readlink > /dev/null; then
                readlink "$(type -P "$1")";
            else
                type -P "$1";
            fi;
        fi
    }
}
_renice () 
{ 
    local command cur curopt i;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    command=$1;
    i=0;
    while [[ $i -le $COMP_CWORD && ${#COMPREPLY[@]} -eq 0 ]]; do
        curopt=${COMP_WORDS[COMP_CWORD-$i]};
        case "$curopt" in 
            -u)
                _allowed_users
            ;;
            -g)
                _pgids
            ;;
            -p | $command)
                _pids
            ;;
        esac;
        i=$(( ++i ));
    done
}
_reply_compgen_array () 
{ 
    local i wlist;
    for i in ${!COMPREPLY[*]};
    do
        local q=$(quote "$(printf %q "${COMPREPLY[$i]}")");
        wlist+=$q'
';
    done;
    local ecur="$cur";
    ecur="${ecur//\\/\\\\}";
    ecur="${ecur//\'/\'}";
    local oldifs=$IFS;
    IFS='
' eval 'COMPREPLY=(`compgen -W "$wlist" -- "${ecur}"`)';
    IFS=$oldifs
}
_repquota () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -s --human-readable \
            -c --batch-translation -C --no-batch-translation -t \
            --truncate-names -n --no-names -p --raw-grace -i --no-autofs \
            -u --user -g --group -F --format' -- "$cur" ));
    else
        _filesystems;
    fi
}
_ri () 
{ 
    local cur class method prefix ri_path ri_version separator IFS;
    local -a classes;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    ri_path=$(type -p ri);
    ri_version="$(ruby -W0 $ri_path -v 2>&1)" || ri_version=integrated;
    [ "$ri_version" != "${ri_version%200*}" ] && ri_version=integrated;
    IFS=', 
	';
    if [[ "$cur" == [A-Z]*[#.]* ]]; then
        [[ "$cur" == *#* ]] && separator=# || separator=.;
        class=${cur%$separator*};
        method=${cur#*$separator};
        classes=($class);
        prefix="-P $class$separator";
        ri_get_methods;
        return 0;
    fi;
    if [ "$ri_version" = integrated ]; then
        classes=($( ri -c | ruby -ne 'if /^\s*$/..$stdin.eof then \
        if /, [A-Z]+/ then print; end; end' ));
    else
        if [ "$ri_version" = "ri 1.8a" ]; then
            classes=($( ruby -W0 $ri_path |             ruby -ne 'if /^'"'"'ri'"'"' has/..$stdin.eof then \
            if /^ .*[A-Z]/ then print; end; end' ));
        else
            classes=($( ruby -W0 $ri_path |             ruby -ne 'if /^I have/..$stdin.eof then \
                if /^ .*[A-Z]/ then print; end; end' ));
        fi;
    fi;
    COMPREPLY=($( compgen -W '${classes[@]}' -- "$cur" ));
    if [[ "$cur" == [A-Z]* ]]; then
        return 0;
    fi;
    method=$cur;
    ri_get_methods
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command $1 $2 $3
}
_rsync () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref -n : cur prev;
    _expand || return 0;
    case $prev in 
        --config | --password-file | --include-from | --exclude-from)
            _filedir;
            return 0
        ;;
        -T | --temp-dir | --compare-dest)
            _filedir -d;
            return 0
        ;;
        -e | --rsh)
            COMPREPLY=($( compgen -W 'rsh ssh' -- "$cur" ));
            return 0
        ;;
        --compress-level)
            COMPREPLY=($( compgen -W '1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($( compgen -W '--verbose --quiet --no-motd --checksum \
                --archive --recursive --relative --no-implied-dirs \
                --backup --backup-dir --suffix= --update --inplace --append \
                --append-verify --dirs --old-dirs --links --copy-links \
                --copy-unsafe-links --safe-links --copy-dirlinks \
                --keep-dirlinks --hard-links --perms --executability --chmod= \
                --acls --xattrs --owner --group --devices --copy-devices \
                --specials --times --omit-dir-times --super --fake-super \
                --sparse --dry-run --whole-file --no-whole-file \
                --one-file-system --block-size= --rsh= --rsync-path= \
                --existing --ignore-existing --remove-source-files --delete \
                --delete-before --delete-during --delete-delay --delete-after \
                --delete-excluded --ignore-errors --force --max-delete= \
                --max-size= --min-size= --partial --partial-dir= \
                --delay-updates --prune-empty-dirs --numeric-ids --timeout= \
                --contimeout= --ignore-times --size-only --modify-window= \
                --temp-dir= --fuzzy --compare-dest= --copy-dest= --link-dest= \
                --compress --compress-level= --skip-compress= --cvs-exclude \
                --filter= --exclude= --exclude-from= --include= \
                --include-from= --files-from= --from0 --protect-args \
                --address= --port= --sockopts= --blocking-io --no-blocking-io \
                --stats --8-bit-output --human-readable --progress \
                --itemize-changes --out-format= --log-file= \
                --log-file-format= --password-file= --list-only --bwlimit= \
                --write-batch= --only-write-batch= --read-batch= --protocol= \
                --iconv= --ipv4 --ipv6 --version --help --daemon --config= \
                --no-detach' -- "$cur" ))
        ;;
        *:*)
            if type _scp_remote_files >&/dev/null; then
                local i shell=ssh;
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -@(e|-rsh) ]]; then
                        shell=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                [ "$shell" = ssh ] && _scp_remote_files;
            fi
        ;;
        *)
            _known_hosts_real -c -a "$cur";
            type _scp_local_files >&/dev/null && _scp_local_files || _filedir
        ;;
    esac;
    return 0
}
_scp () 
{ 
    local configfile cur prev prefix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && { 
        COMPREPLY=("${COMPREPLY[@]/%/ }");
        return 0
    };
    case $prev in 
        -l | -P)
            return 0
        ;;
        -F | -i | -S)
            _filedir;
            type compopt >&/dev/null && compopt +o nospace;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            COMPREPLY=("${COMPREPLY[@]/%/ }");
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    _expand || return 0;
    if [[ "$cur" == *:* ]]; then
        _scp_remote_files;
        return 0;
    fi;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        prefix=-F;
    else
        set -- "${COMP_WORDS[@]}";
        while [ $# -gt 0 ]; do
            if [ "${1:0:2}" = -F ]; then
                if [ ${#1} -gt 2 ]; then
                    configfile="$(dequote "${1:2}")";
                else
                    shift;
                    [ "$1" ] && configfile="$(dequote "$1")";
                fi;
                break;
            fi;
            shift;
        done;
        case $cur in 
            -*)
                COMPREPLY=($( compgen -W '-1 -2 -4 -6 -B -C -c -F -i -l -o \
                    -P -p -q -r -S -v' -- "$cur" ));
                COMPREPLY=("${COMPREPLY[@]/%/ }");
                return 0
            ;;
            */*)

            ;;
            *)
                _known_hosts_real -c -a -F "$configfile" "$cur"
            ;;
        esac;
    fi;
    _scp_local_files "$prefix";
    return 0
}
_scp_local_files () 
{ 
    local IFS='
';
    local dirsonly=false;
    if [ "$1" = -d ]; then
        dirsonly=true;
        shift;
    fi;
    if $dirsonly; then
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e '/[^\/]$/d' -e "s/^/$1/"));
    else
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' -e "s/^/$1/"));
    fi
}
_scp_remote_files () 
{ 
    local IFS='
';
    cur=${cur/\\:/:};
    local userhost=${cur%%?(\\):*};
    local path=${cur#*:};
    path=$( sed -e 's/\\\\\\\('$_scp_path_esc'\)/\\\1/g' <<<"$path" );
    if [ -z "$path" ]; then
        path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null);
    fi;
    local files;
    if [ "$1" = -d ]; then
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e '/[^\/]$/d' );
    else
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' );
    fi;
    COMPREPLY=("${COMPREPLY[@]}" $files)
}
_screen () 
{ 
    local cur prev words cword;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev words cword;
    if ((cword > 2)); then
        case ${words[cword-2]} in 
            -[dD])
                _screen_sessions;
                return 0
            ;;
        esac;
    fi;
    case $prev in 
        -[rR])
            _screen_sessions 'Detached';
            return 0
        ;;
        -[dD])
            _screen_sessions 'Attached';
            return 0
        ;;
        -x)
            _screen_sessions;
            return 0
        ;;
        -s)
            _shells;
            return 0
        ;;
        -c)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -A -c -d -D -e -f -fn -fa -h -i -ln \
            -list -L -m -O -p -q -r -R -s -S -t -U -v -wipe -x -X --help \
            --version' -- "$cur" ));
    fi
}
_screen_sessions () 
{ 
    COMPREPLY=($( compgen -W "$( command screen -ls | sed -ne         's|^\t\{1,\}\([0-9]\{1,\}\.[^\t]\{1,\}\).*'"$1"'.*$|\1|p' )"         -- "$cur" ))
}
_services () 
{ 
    local sysvdir famdir;
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    famdir=/etc/xinetd.d;
    COMPREPLY=($( printf '%s\n'         $sysvdir/!(*.rpm@(orig|new|save)|*~|functions) ));
    if [ -d $famdir ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( printf '%s\n'             $famdir/!(*.rpm@(orig|new|save)|*~) ));
    fi;
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- "$cur" ))
}
_setquota () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r --remote -m --no-mixed-pathnames \
            -F --format -g --group -u --user -p --prototype -b --batch \
            -c --continue-batch -t --edit-period -T --edit-times -a --all'             -- "$cur" ));
    else
        _count_args;
        case $args in 
            1)
                _user_or_group
            ;;
            2)
                _filesystems
            ;;
        esac;
    fi
}
_sftp () 
{ 
    local cur prev configfile;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _ssh_suboption_check && return 0;
    case $prev in 
        -b | -F | -P)
            _filedir;
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -C -v -B -b -F -o -P -R -S -s'             -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
        fi;
    fi;
    return 0
}
_sh () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            return 0
        ;;
        -o | +o)
            COMPREPLY=($( compgen -W 'allexport errexit ignoreeof monitor
                noclobber noglob noexec nolog notify nounset verbose vi
                xtrace' -- "$cur" ));
            return 0
        ;;
    esac;
    local opts="-a -b -C -e -f -h -i -m -n -o -u -v -x";
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$opts -c -s" -- "$cur" ));
        return 0;
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W "${opts//-/+}" -- "$cur" ));
            return 0;
        fi;
    fi;
    _filedir sh
}
_shells () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         '$( command grep "^[[:space:]]*/" /etc/shells 2>/dev/null )'         -- "$cur" ))
}
_signals () 
{ 
    local i;
    COMPREPLY=($( compgen -A signal SIG${cur#-} ));
    for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
    do
        COMPREPLY[i]=-${COMPREPLY[i]#SIG};
    done
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sqlite3 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    local dbexts='@(sqlite?(3)|?(s?(3))db)';
    case $prev in 
        -help | -version | -separator | -nullvalue | *.$dbexts)
            return 0
        ;;
        -init)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-help -init -echo -header -noheader -bail
            -interactive -batch -column -csv -html -line -list -separator
            -nullvalue -version' -- "$cur" ));
        return 0;
    fi;
    _filedir $dbexts
}
_ssh () 
{ 
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && return 0;
    case $prev in 
        -F | -i | -S)
            _filedir;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            return 0
        ;;
        -m)
            _ssh_macs;
            return 0
        ;;
        -l)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
        -w)
            _available_interfaces;
            return 0
        ;;
        -b)
            _ssh_bindaddress;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -2 -4 -6 -A -a -C -f -g -K -k -M \
            -N -n -q -s -T -t -V -v -X -v -Y -y -b -b -c -D -e -F \
            -i -L -l -m -O -o -p -R -S -w' -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
            if [ $COMP_CWORD -ne 1 ]; then
                _compopt_o_filenames;
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -c -- "$cur" ));
            fi;
        fi;
    fi;
    return 0
}
_ssh_bindaddress () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         "$( PATH="$PATH:/sbin" ifconfig -a |         sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'             -ne 's/.*inet[[:space:]]\{1,\}\([^[:space:]]*\).*/\1/p' )"         -- "$cur" ))
}
_ssh_ciphers () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '3des-cbc aes128-cbc \
        aes192-cbc aes256-cbc aes128-ctr aes192-ctr aes256-ctr arcfour128 \
        arcfour256 arcfour blowfish-cbc cast128-cbc' -- "$cur" ))
}
_ssh_copy_id () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -i)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-i' -- "$cur" ));
    else
        _known_hosts_real -a "$cur";
    fi;
    return 0
}
_ssh_macs () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'hmac-md5 hmac-sha1 \
        umac-64@openssh.com hmac-ripemd160 hmac-sha1-96 hmac-md5-96'         -- "$cur" ))
}
_ssh_options () 
{ 
    type compopt >&/dev/null && compopt -o nospace;
    COMPREPLY=($( compgen -S = -W 'AddressFamily BatchMode BindAddress \
        ChallengeResponseAuthentication CheckHostIP Cipher Ciphers \
        ClearAllForwardings Compression CompressionLevel ConnectionAttempts \
        ConnectTimeout ControlMaster ControlPath DynamicForward EscapeChar \
        ExitOnForwardFailure ForwardAgent ForwardX11 ForwardX11Trusted \
        GatewayPorts GlobalKnownHostsFile GSSAPIAuthentication \
        GSSAPIDelegateCredentials HashKnownHosts Host HostbasedAuthentication \
        HostKeyAlgorithms HostKeyAlias HostName IdentityFile IdentitiesOnly \
        KbdInteractiveDevices LocalCommand LocalForward LogLevel MACs \
        NoHostAuthenticationForLocalhost NumberOfPasswordPrompts \
        PasswordAuthentication PermitLocalCommand Port \
        PreferredAuthentications Protocol ProxyCommand PubkeyAuthentication \
        RekeyLimit RemoteForward RhostsRSAAuthentication RSAAuthentication \
        SendEnv ServerAliveInterval ServerAliveCountMax SmartcardDevice \
        StrictHostKeyChecking TCPKeepAlive Tunnel TunnelDevice \
        UsePrivilegedPort User UserKnownHostsFile VerifyHostKeyDNS \
        VisualHostKey XAuthLocation' -- "$cur" ))
}
_ssh_suboption () 
{ 
    local prev=${1%%=*} cur=${1#*=};
    case $prev in 
        BatchMode | ChallengeResponseAuthentication | CheckHostIP | ClearAllForwardings | Compression | ExitOnForwardFailure | ForwardAgent | ForwardX11 | ForwardX11Trusted | GatewayPorts | GSSAPIAuthentication | GSSAPIKeyExchange | GSSAPIDelegateCredentials | GSSAPITrustDns | HashKnownHosts | HostbasedAuthentication | IdentitiesOnly | KbdInteractiveAuthentication | KbdInteractiveDevices | NoHostAuthenticationForLocalhost | PasswordAuthentication | PubkeyAuthentication | RhostsRSAAuthentication | RSAAuthentication | StrictHostKeyChecking | TCPKeepAlive | UsePrivilegedPort | VerifyHostKeyDNS | VisualHostKey)
            COMPREPLY=($( compgen -W 'yes no' -- "$cur"))
        ;;
        AddressFamily)
            COMPREPLY=($( compgen -W 'any inet inet6' -- "$cur" ))
        ;;
        BindAddress)
            _ssh_bindaddress
        ;;
        Cipher)
            COMPREPLY=($( compgen -W 'blowfish des 3des' -- "$cur" ))
        ;;
        Protocol)
            COMPREPLY=($( compgen -W '1 2 1,2 2,1' -- "$cur" ))
        ;;
        Tunnel)
            COMPREPLY=($( compgen -W 'yes no point-to-point ethernet'                     -- "$cur" ))
        ;;
        PreferredAuthentications)
            COMPREPLY=($( compgen -W 'gssapi-with-mic host-based \
                    publickey keyboard-interactive password' -- "$cur" ))
        ;;
        MACs)
            _ssh_macs
        ;;
        Ciphers)
            _ssh_ciphers
        ;;
    esac;
    return 0
}
_ssh_suboption_check () 
{ 
    local cureq=`_get_cword :=` preveq=`_get_pword :=`;
    if [[ $cureq == *=* && $preveq == -o ]]; then
        _ssh_suboption $cureq;
        return $?;
    fi;
    return 1
}
_sysctl () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W         "$( PATH="$PATH:/sbin" sysctl -N -a 2>/dev/null )" -- "$cur" ));
    return 0
}
_tar () 
{ 
    local cur ext regex tar untar;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u r d A' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in 
        ?(-)[cr]*f)
            _filedir;
            return 0
        ;;
        +([^IZzJjy])f)
            ext='@(@(tar|gem|spkg)?(.@(Z|[gx]z|bz?(2)|lzma))|t@([glx]z|bz?(2)))';
            regex='\(\(tar\|gem\|spkg\)\(\.\(Z\|[gx]z\|bz?(2)\|lzma\)\)\?\|t\([glx]z\|bz2\?\)\)'
        ;;
        *[Zz]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(gz|Z)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(gz\|Z\)'
        ;;
        *[Ijy]*f)
            ext='@(@(t?(ar.)|gem.)bz?(2)|spkg)';
            regex='\(\(t\(ar\.\)\?\|gem\.\)bz2\?\|spkg\)'
        ;;
        *[J]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(lz?(ma)|xz)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(lzma\|xz\)\?'
        ;;
        *)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$COMP_LINE" == *$ext' ' ]]; then
        tar=$( sed -e 's/^.* \([^ ]*'$regex'\) .*$/\1/' <<<"$COMP_LINE" );
        untar=t${COMP_WORDS[1]//[^Izjyf]/};
        local IFS='
';
        COMPREPLY=($( compgen -W "$( printf '%s\n' $( tar $untar $tar             2>/dev/null ) )" -- "$cur" ));
        return 0;
    fi;
    _filedir "$ext";
    return 0
}
_tcpdump () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -r | -w | -F)
            _filedir;
            return 0
        ;;
        -i)
            _available_interfaces -a;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -e -f -l -n -N -O -p \
            -q -R -S -t -u -v -x -C -F -i -m -r -s -T -w -E' -- "$cur" ));
    fi
}
_tilde () 
{ 
    local result=0;
    if [[ ${1:0:1} == "~" && $1 == ${1//\/} ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
    fi;
    return $result
}
_uids () 
{ 
    if type getent >&/dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl >&/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_umount () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=();
    if [[ $(uname -s) = Linux && -r /proc/mounts ]]; then
        _linux_fstab < /proc/mounts;
    else
        local IFS='
';
        COMPREPLY=($( compgen -W '$( mount | cut -d" " -f 3 )' -- "$cur" ));
    fi;
    return 0
}
_unpack200 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--deflate-hint= --remove-pack-file \
                --verbose --quiet --log-file= --help --version' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt >&/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" >&/dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_user_or_group () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -g ]]; then
            COMPREPLY=($( compgen -g -- "$cur" ));
            return 0;
        fi;
    done;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_vipw () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h | --help)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--group --help --passwd \
            --quiet --shadow' -- "$cur" ));
        return 0;
    fi
}
_xhost () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    case $cur in 
        +*)
            _known_hosts_real -p+ "${cur:1}"
        ;;
        -*)
            _known_hosts_real -p- "${cur:1}"
        ;;
        *)
            _known_hosts_real "$cur"
        ;;
    esac;
    return 0
}
_xmllint () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | --output)
            _filedir;
            return 0
        ;;
        --path | --dtdvalidfpi | --maxmem | --encode | --pattern)
            return 0
        ;;
        --dtdvalid)
            _filedir 'dtd?(.gz)';
            return 0
        ;;
        --relaxng)
            _filedir 'rng?(.gz)';
            return 0
        ;;
        --schema)
            _filedir 'xsd?(.gz)';
            return 0
        ;;
        --schematron)
            _filedir 'sch?(.gz)';
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$( xmllint --help 2>&1 | \
            sed -ne "s/^[[:space:]]*\(--[^[:space:]:]*\).*/\1/p" ) \
            -o' -- "$cur" ));
        return 0;
    fi;
    _filedir '@(*ml|htm|svg|xs[dl]|rng|wsdl|jnlp)?(.gz)'
}
_xmodmap () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -display | -e)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-display -help -grammar -verbose -quiet -n
            -e -pm -pk -pke -pp' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_xrandr () 
{ 
    local cur prev output modes;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --output)
            local outputs=$(xrandr|awk '/connected/ {print $1}');
            COMPREPLY=($(compgen -W "$outputs" -- "$cur"));
            return 0
        ;;
        --mode)
            for ((i = 1; i < COMP_CWORD; i++ ))
            do
                if [[ "${COMP_WORDS[i]}" == "--output" ]]; then
                    output=${COMP_WORDS[i+1]};
                    break;
                fi;
            done;
            modes=$(xrandr|sed -e "1,/$output/ d"                 -e "/connected/,$ d"|awk '{print $1}');
            COMPREPLY=($( compgen -W "$modes" -- "$cur"));
            return 0
        ;;
    esac;
    case $cur in 
        *)
            COMPREPLY=($(compgen -W '-display -help --orientation --query \
                --size --rate --version -x -y --screen --verbose --dryrun \
                --prop --fb --fbmm --dpi --output --auto --mode --preferred \
                --pos --reflect --rotate --left-of --right-of --above --below \
                --same-as --set --off --crtc --newmode --rmmode --addmode \
                --delmode' -- "$cur"));
            return 0
        ;;
    esac;
    return 0
}
_xrdb () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -backup | -display | -help)
            return 0
        ;;
        -cpp | -edit)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-help -display -all -global -screen -screens
            -n -quiet -cpp -nocpp -symbols -query -load -override -merge
            -remove -retain -edit -backup' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_xsltproc () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --output | -o)
            _filedir;
            return 0
        ;;
        --maxdepth)
            return 0
        ;;
        --encoding)
            COMPREPLY=($( compgen -W "$( iconv -l | sed -e '/^UTF[1378]/d'                 -e '/^ISO[0-9_]/d' -e '/^8859/d' -e 's/\/.*//')" -- "$cur" ));
            return 0
        ;;
        --param | --stringparam)
            return 0
        ;;
        --path)
            _filedir -d;
            return 0
        ;;
        --writesubtree)
            _filedir -d;
            return 0
        ;;
    esac;
    [[ $COMP_CWORD -gt 2 && `_get_cword '' 2` == --?(string)param ]] && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt xsltproc;
    else
        _filedir '@(xsl|xslt|xml)';
    fi
}
_xz () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--compress --decompress --test --list \
            --keep --force --stdout --suffix --files --files0 --format --check \
            -0 -1 -2 -3 -4 -5 -6 -7 -8 -9 --fast --best --extreme --memory \
            --lzma1 --lzma2 --x86 --powerpc --ia64 --arm --armthumb --sparc \
            --delta --quiet --verbose --no-warn --help --long-help --version'             -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    local xspec="*.@(xz|lzma|txz|tlz)";
    case $prev in 
        --decompress | --list | --test | -!(-*)[dlt]*)
            xspec="!"$xspec
        ;;
        --files | --files0)
            _filedir;
            return 0
        ;;
        -C | --check)
            COMPREPLY=($( compgen -W 'crc32 crc64 sha256' -- "$cur" ));
            return 0
        ;;
        -F | --format)
            COMPREPLY=($( compgen -W 'auto xz lzma raw' -- "$cur" ));
            return 0
        ;;
        -M | --memory | -S | --suffix | --delta | --lzma1 | --lzma2)
            return 0
        ;;
        -h | --help | -H | --long-help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _expand || return 0;
    local IFS='
';
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_xzdec () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--memory --help --version' -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    case $prev in 
        -M | --memory)
            return 0
        ;;
        -h | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _filedir xz
}
dequote () 
{ 
    eval echo "$1" 2> /dev/null
}
masm () 
{ 
    ( set -e;
    export WINEPREFIX=$WINE_MASM_DIR;
    FILENAME="$(basename "$1")";
    EXTENSION="${FILENAME##*.}";
    shopt -s nocasematch;
    if [[ "$EXTENSION" = "asm" ]]; then
        FILENAME="${FILENAME%.*}";
    fi;
    UNIX_PATH="$(dirname "$1")/$FILENAME";
    WINDOWS_PATH=$(echo "$UNIX_PATH" | tr '/' '\');
    wine ml -nologo -c -coff -Zi "$WINDOWS_PATH.asm";
    wine link /NOLOGO /SUBSYSTEM:CONSOLE /ENTRY:main /LIBPATH:'C:\Irvine' irvine32.lib kernel32.lib user32.lib "$WINDOWS_PATH.obj";
    wine "$WINDOWS_PATH.exe" )
}
quote () 
{ 
    echo \'${1//\'/\'\\\'\'}\'
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
rbenv () 
{ 
    local command;
    command="$1";
    if [ "$#" -gt 0 ]; then
        shift;
    fi;
    case "$command" in 
        rehash | shell)
            eval "$(rbenv "sh-$command" "$@")"
        ;;
        *)
            command rbenv "$command" "$@"
        ;;
    esac
}
ri_get_methods () 
{ 
    local regex;
    if [ "$ri_version" = integrated ]; then
        if [ -z "$separator" ]; then
            regex="(Instance|Class)";
        else
            if [ "$separator" = "#" ]; then
                regex=Instance;
            else
                regex=Class;
            fi;
        fi;
        COMPREPLY=(${COMPREPLY[@]} "$( ri ${classes[@]} 2>/dev/null | ruby -ane             'if /^'"$regex"' methods:/.../^------------------|^$/ and \
            /^ / then print $_.split(/, |,$/).grep(/^[^\[]*$/).join("\n"); \
            end' | sort -u )");
    else
        COMPREPLY=(${COMPREPLY[@]} "$( ruby -W0 $ri_path ${classes[@]} | ruby -ane             'if /^-/.../^-/ and ! /^-/ and ! /^ +(class|module): / then \
            print $_.split(/, |,$| +/).grep(/^[^\[]*$/).join("\n"); \
            end' | sort -u )");
    fi;
    COMPREPLY=($( compgen $prefix -W '${COMPREPLY[@]}' -- $method ))
}
shell_session_delete_expired () 
{ 
    if ( [ ! -e "$SHELL_SESSION_TIMESTAMP_FILE" ] || [ -z "$(/usr/bin/find "$SHELL_SESSION_TIMESTAMP_FILE" -mtime -1d)" ] ); then
        local expiration_lock_file="$SHELL_SESSION_DIR/_expiration_lockfile";
        if /usr/bin/shlock -f "$expiration_lock_file" -p $$; then
            echo -n 'Deleting expired sessions...';
            local delete_count=$(/usr/bin/find "$SHELL_SESSION_DIR" -type f -mtime +2w -print -delete | /usr/bin/wc -l);
            [ "$delete_count" -gt 0 ] && echo $delete_count' completed.' || echo 'none found.';
            ( umask 077;
            /usr/bin/touch "$SHELL_SESSION_TIMESTAMP_FILE" );
            /bin/rm "$expiration_lock_file";
        fi;
    fi
}
shell_session_history_allowed () 
{ 
    if [ -n "$HISTFILE" ]; then
        local allowed=0;
        if shopt -q histappend || [ -n "$HISTTIMEFORMAT" ]; then
            allowed=${SHELL_SESSION_HISTORY:-0};
        else
            allowed=${SHELL_SESSION_HISTORY:=1};
        fi;
        if [ $allowed -eq 1 ]; then
            return 0;
        fi;
    fi;
    return 1
}
shell_session_history_check () 
{ 
    if [ ${SHELL_SESSION_DID_HISTORY_CHECK:-0} -eq 0 ]; then
        SHELL_SESSION_DID_HISTORY_CHECK=1;
        if shell_session_history_allowed; then
            shell_session_history_enable;
        fi;
        if [ "$PROMPT_COMMAND" = "shell_session_history_check" ]; then
            unset PROMPT_COMMAND;
        else
            if [[ $PROMPT_COMMAND =~ (.*)(; *shell_session_history_check *| *shell_session_history_check *; *)(.*) ]]; then
                PROMPT_COMMAND="${BASH_REMATCH[1]}${BASH_REMATCH[3]}";
            fi;
        fi;
    fi
}
shell_session_history_enable () 
{ 
    ( umask 077;
    /usr/bin/touch "$SHELL_SESSION_HISTFILE_NEW" );
    HISTFILE="$SHELL_SESSION_HISTFILE_NEW";
    SHELL_SESSION_HISTORY=1
}
shell_session_save () 
{ 
    if [ -n "$SHELL_SESSION_FILE" ]; then
        echo -n 'Saving session...';
        ( umask 077;
        echo 'echo Restored session: "$(/bin/date -r '$(/bin/date +%s)')"' >|"$SHELL_SESSION_FILE" );
        declare -F shell_session_save_user_state > /dev/null && shell_session_save_user_state;
        shell_session_history_allowed && shell_session_save_history;
        echo 'completed.';
    fi
}
shell_session_save_history () 
{ 
    shell_session_history_enable;
    history -a;
    if [ -f "$SHELL_SESSION_HISTFILE_SHARED" ] && [ ! -s "$SHELL_SESSION_HISTFILE" ]; then
        echo -ne '\n...copying shared history...';
        ( umask 077;
        /bin/cp "$SHELL_SESSION_HISTFILE_SHARED" "$SHELL_SESSION_HISTFILE" );
    fi;
    echo -ne '\n...saving history...';
    ( umask 077;
    /bin/cat "$SHELL_SESSION_HISTFILE_NEW" >> "$SHELL_SESSION_HISTFILE_SHARED" );
    ( umask 077;
    /bin/cat "$SHELL_SESSION_HISTFILE_NEW" >> "$SHELL_SESSION_HISTFILE" );
    : >|"$SHELL_SESSION_HISTFILE_NEW";
    if [ -n "$HISTFILESIZE" ]; then
        echo -n 'truncating history files...';
        HISTFILE="$SHELL_SESSION_HISTFILE_SHARED";
        HISTFILESIZE="$HISTFILESIZE";
        HISTFILE="$SHELL_SESSION_HISTFILE";
        HISTFILESIZE="$size";
        HISTFILE="$SHELL_SESSION_HISTFILE_NEW";
    fi;
    echo -ne '\n...'
}
shell_session_update () 
{ 
    shell_session_save && shell_session_delete_expired
}
update_terminal_cwd () 
{ 
    local url_path='';
    { 
        local i ch hexch LC_CTYPE=C LC_ALL=;
        for ((i = 0; i < ${#PWD}; ++i))
        do
            ch="${PWD:i:1}";
            if [[ "$ch" =~ [/._~A-Za-z0-9-] ]]; then
                url_path+="$ch";
            else
                printf -v hexch "%02X" "'$ch";
                url_path+="%${hexch: -2:2}";
            fi;
        done
    };
    printf '\e]7;%s\a' "file://$HOSTNAME$url_path"
}
alias apps='cd ~/Applications'
alias l='ls -GFh'
alias la='ls -a -GFh'
alias ll='ls -l -GFh'
alias ls='ls -GFh'
alias lsa='ls -al -GFh'
alias oc='cd ~/code/c'
alias ocode='cd ~/code'
alias ojava='cd ~/code/java'
alias opy='cd ~/code/py'
alias oshell='cd ~/code/shell'
alias pyt='python3'
export PATH=/Users/adityakaria/.rbenv/shims:/usr/local/bin:/Users/adityakaria/flutter/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/opt/X11/bin:~/.dotnet/tools:/Library/Frameworks/Mono.framework/Versions/Current/Commands
